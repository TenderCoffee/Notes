运行时音频处理会成为 CPU 和 内存消耗的 重要来源



# 音频加载

加载音频数据只是表示将音频数据加入到主内存（RAM）中，稍后由音频解码器进行处理，然后将数据转换为音频信号，送到耳机或者扬声器



## 音频加载三种方式

1、Preload Audio Data

​	在场景初始化期间自动加载

​	禁用 = 需要使用的时候才加载 = 第一次播放文件的时候CPU立即访问磁盘，检索文件，将其加载到内存，解压并播放 = **同步操作 = 阻塞主线程 = 掉帧**

2、Load In Background

​	加载音频的行为 在后台（不阻塞主线程）= 异步任务 = 不会阻塞主线程

​	（**以后才需要的音频剪辑启用，通过 AudioClip.LoadAudioData 和 AudioClip.UnloadAudioData 手动控制音频数据加载时间**）

3、Load Type 音频数据如何加载

​	将什么类型的数据拉入内存，一次拉入多少数据

​	Decompress On Load：压缩磁盘音频文件节省空间，首次加载时将其解压到内存中（**标准做法，大多数时候使用**）

​	Compressed in Memory：

​			在加载音频时只是将其直接从磁盘复制到内存中。只有播放音频文件的时候才会在运行期间对其进行解压缩

​			播放时 牺牲 CPU，不播放时提高加载速度

​			（适合 **频繁使用的大型音频文件** 或者 内存消耗上遇到拼接愿意牺牲CPU播放音频剪辑）

​	Streaming

​			流，缓冲。在运行时加载、解码和播放文件。

​			逐步将文件推到一个小缓冲区，在缓冲区一次只存在整个文件的一小部分数据。

​			（**内存成本低，因为需要运行时的硬盘访问，所以仅限于大型的单实例文件，最慢的数据访问形式，主要用于背景音乐/环境音效**）

​			文件的每个播放实例需要生成自己缓冲区 = 多次引用音频剪辑导致内存中同一音频剪辑的多个副本必须单独处理



## AudioClip

AudioClip.LoadAudioData：阻塞主线程方式下的加载 = 掉帧

AudioClip.UnloadAudioData ：卸载数据

AudioClip.loadState：检查AudioClip 的当前加载状态



## AudioSource 对象

audioClip 属性：将音频文件包装在 AudioClip 对象中

Play / PlayOnShot：播放



# 音频剪辑编码格式

非移动平台：Ogg

移动平台：Mp3



# 音频压缩

Compression Format：

​	Compressed：不影响文件采样率的情况下更改质量（质量：ADPCM < Compressed< PCM，使用额外CPU，**大多数时候使用**）

​	PCM：无损未压缩，高质量音频 （适用于极短暂且高清晰度）

​	ADPCM：文件更小，CPU消耗更小，但压缩会产生大的噪声（用于“混乱”的短声音 = 爆炸，碰撞）



# 音频性能加强

1、最小化活动音频数量

禁用冗余音频源可以节省CPU周期

限制可以同时播放音频剪辑的实例数（**同时播放100个人走步声音 = 10个人走步声音 = 无区别 = 只播放10个**）

2、为3D声音启用强制单声道

Force to Mono：将来自两个音频通道的数据混合到一个同道中人，磁盘和内存空间降低50%（**2D音效不需要、3D位置音频才需要**）

3、重新采样到低频

可以减小文件和运行时内存占用

Sample Rate - Override Sample Rate

（**高音调，音乐文件才需要高音频**）

4、使用 Compressed、PCM、ADPCM 对不同文件使用不同的编码格式进行不同的压缩

5、流媒体内存低，但使用主要在 **背景音乐/环境音效**

6、混音器修改通过音频播放的音效，通过 FilterEffect 组件完成

7、如果使用服务器下载的音频流，必须在不使用资源的时候释放

​	WWW、 UnityWebRequest  - Resources.UnloadAsset

8、音频模块文件节省大量空间没有明显质量丢失，适合用在背景音乐

​	格式（.it、.s3.、.xm、.mod）









