# 场景性能瓶颈

1、同屏渲染面数太多，GPU 压力太大

2、渲染管线调用次数太多（DrawCall 太多），GPU 的并行处理没有很好发挥作用

3、贴图太大，压缩格式不合适，占用内存多导致显存的带宽负荷大

4、动态太多，蒙皮在骨骼上的计算消耗的 CPU多

5、复杂的着色器开销太大，GPU的计算量开销太大

6、实时阴影

7、透贴太多导致 Overdraw 问题严重

8、物体需要的管线渲染太多，一个物体需要多次绘制



# 1、同屏渲染面数

同屏展示面数太多，网格面数太多，内存上升



## 摄像机里“同屏的”渲染面数才是比较重要的

多模型进入摄像机的渲染范围导致



包围盒裁剪：Unity 提交 GPU 前会对模型进行一次裁剪（消耗CPU）

进入渲染管线前，每个3D物体已经计算好一个包围盒（Bounds）

包围盒的8个顶点组成 + 旋转矩阵 = 计算出每个顶点是否在摄像头的锥形体范围内

只要有1个顶点在锥形体范围内就是需要渲染的不会被裁剪掉

8个点都没有在锥形体范围内就可以被屏蔽掉不被渲染



Unity引擎上的裁剪，不需要手动设置，所以模型制作的时候要注意包围盒大小就可以



## LOD：内存换 CPU 和 GPU

把3D模型制作成多个不同细节级别的模型文件

面数少的：远距离渲染

面数多的：近距离渲染



缺点：

​	分级少了画面突兀，分级多了增大内存量和制作时间



### Mipmap：类似 LOD 优化性能

Mipmap 的主要目的：

​	处理因为物体像素比导致的画面瑕疵，根据远近选择贴图大小，节省 GPU 和 内存之间的传输数据的带宽

​	远的：更小的纹理贴图



## 具体优化步骤

1、**制作模型的时候，让包围盒适应好模型大小**

2、**模型不要做很大很长**，这会让包围盒进入视野，导致包围盒裁剪优化失效，浪费了很多GPU（因为网格传入后，由 GPU 对每个三角形进行裁剪，这个裁剪更费力） 

3、**模型也不要拆分太细**，拆分太细会带来更多的 DrawCall

4、关注摄像机参数，**摄像机远切面不要太长**，包含太多物体在视野内也会导致包围盒裁剪失效增大后面GPU的压力，如果需要看的更多更远的物体，但是又项降低渲染带宽压力，就使用 LOD

​	**LOD：内存换 CPU 和 GPU**



# 2、渲染管线调用次数（DrawCall ）

渲染管线调用次数太多，GPU 的并行处理没有发挥很好的作用

场景模型太多 或者 模型中的着色器管线太多 导致 DrawCall 太多



## 合批（合并模型）

场景单个模型的数量不减少的情况下，需要渲染的三角形面数已经确定，调用渲染管线渲染都会将这些三角形 传输给渲染管线，如果合并三角形面片一并传输给管线，则可以让多次调用变为一次，让 GPU 可以更好的并行处理

虽然排队的数据量大，但排队的数据量少了



### 动态合批 - Unity自动完成

对模型面数、法线、切线、管线数都有要求



### 静态合批

对模型的要求比动态合批要少

消耗硬盘和内存换取CPU



### GPU Instancing 合批

在渲染一个模型时通过传递更多的数据让它绘制在不同的位置，从而减少 DrawCall



### 开发者手动合批

如果 模型材质球使用的着色器参数一样，只是贴图不一样：

方法1：先离线合批贴图，再将贴图放到实时渲染时进行合批

方法2：先实时合批贴图，再将贴图传入材质球，重新设置UV



#### 实时合批

​	因为会需要读取多个模型，并创建新模型数据，不断创建新模型数据，所以会消耗大量 CPU



**合批的要求：使用相同的材质**

读取具有相同材质球的模型数据，生成一个新的合批后的模型，需要把原有的模型隐藏避免重叠显示



#### 离线合批（静态合批）

1、手动拼接场景中静态不动，有相同材质的模型

2、使用 MeshBaker 插件制作和合批模型与纹理贴图



优点：不需要实时消耗CPU合并模型，节省实时开销的CPU，减少 DrawCall的数量



### 合批的缺点

合批太多模型，变成一个模型，会导致包围盒裁剪失效，同屏渲染面数变多，增大了 GPU 的计算压力

合批要适度：

​	合批附近距离不太远的、可以称为一块范围内的模型



## 具体优化步骤

1、场景中不要有太多的模型物体

2、注释掉 着色器代码中的不必要的管线

3、动态合批 + 静态合批（不建议使用） + GPU Instanceing 合批 + 手动合批（建议使用）





# 3、贴图占用内存

因为贴图的加载，会将内存的纹理复制到显存中，才能在 GPU 中渲染

所以贴图占用内存大，会导致显存带宽压力大



注意：手机  没有 显存的概念，PC 和 主机 才有显存

手机设备中的显存都是内存的复制，手机会为 GPU 预留出一块专门用于渲染的内存块作为缓存



## Read/Write

内存的存取：

PC：纹理有两份，一份在内存一份在显存

Android/IOS：CPU 和 GPU 的纹理地址指向同个物理地址

​	Unity 中的 贴图选项 ： Read/Write 勾选后多一个复制，造成2倍内存

 

## 贴图大小

影响 GPU的复制，缩小和压缩贴图

1、Icon 图集：一般无损

2、UI 贴图：适当压缩



3、3D 模型贴图

2的幂次方大小（**GPU对2次幂大小的贴图处理更快点**）

主流：ASTC压缩



## 具体优化步骤

1、不需要读写操作的贴图，不用开启 Read/Write

2、保证画面质量的前提下，缩小和压缩贴图（UI、模型贴图）

3、尽量使用2次幂大小



# 4、动画

动画太多，蒙皮计算消耗CPU太多

模型动画是时时刻刻都在计算网格的位置，不在屏幕上也会保持动画的计算



CPU 在蒙皮计算上消耗极大

CPU 的蒙皮计算 实质是骨骼与顶点的计算

骨骼动画用骨骼点去影响顶点

每帧都需要计算骨骼点与顶点的偏移、缩放与旋转



## 程序优化

把每个动画网格分批计算好，并将其另存为一个文件，多少帧动画 = 多少个具体网格

每次播放动画的时候直接用网格替换省去网格顶点的计算



缺点：内存占用量上升

一个动画 = 一个 DrawCall

100个动画 = 100个 DrawCall

解决：

**GPU  Instancing**：合并相同材质球，相同模型的 DrawCall

**原理：将一个模型以不同的状态在不同的位置渲染，只需要提交一次GPU**



SkinMesh Instancing：建立在 GPU  Instancing 上的动画优化方案

1、把动画的模型数据（网格顶点的偏移量）在离线状态下计算好并存储在贴图中

2、可编程的顶点着色器根据参数来完成顶点的偏移

解放了CPU的算力（不需要计算），转移到GPU渲染（一次提交就渲染很多个位置的模型，渲染只需将顶点偏移）





## 具体优化步骤

1、美术上减少顶点数量

2、美术上减少骨骼点数量

3、程序上把计算好的每帧顶点偏移量保存起来，播放的时候直接偏移过去（SkinMesh Instancing）

4、着色器的纯顶点算法动画（消耗GPU 并行算力，解放 CPU 算力）



# 5、着色器开销

片段着色器中不要计算复杂逻辑

​	片段着色器针对每个像素计算

​	顶点着色器 针对每个顶点计算

​	顶点着色器处理的数量更少

​	

## 数学函数

复杂的数学函数消耗GPU开销

pow、exp、log、cos、sin、tan



## 变体

1、使用multi_compile或shader_feature后，着色器会编译出很多的变体。

引擎在识别功能时会选择对应的着色器，这导致很多没有被初始化的着色器会被临时初始化，这会造成卡顿。

2、另外，变体的使用也加大了内存的使用量，有些项目的变体内存占用量就达到50MB，因此使用时需要谨慎些



## 手机设备 上的 Alpha Test 

手机 Alpha Test 会让前置深度测试（Pre Depth Test）失效，导致性能开销



## 着色器中的数值计算

尽量采用预先计算好的值降低消耗



## 具体优化步骤

1、复杂逻辑的算力，放到顶点着色器中，节省GPU消耗

2、使用近似公式替代复杂的数学函数

3、少点使用变体

4、移动设备中，小心使用 Alpha Test 与 前置深度测试 的冲突

5、着色器实时计算使用预先计算好的值

6、控制变量精度减少不必要精度开销

7、着色器中不使用过多的 if else
