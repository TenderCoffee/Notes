# HTTP/2 和 HTTP/1.x



## 数据传输的区别

HTTP/2：采用 二进制格式传输协议

HTTP/1.x ：采用 文本格式 传输

![](..\images\HTTP2 采用 二进制格式传输协议.png)



## 多路复用的区别

HTTP/2：同一个连接发送多个并发的请求

HTTP/1.x ：通过 pipeline 也能并发请求，但多个请求之间的响应依然会被阻塞

![](..\images\HTTP2 多路复用的区别.png)



## 服务端推送

服务端推送是一种在客户端请求之前发送数据的机制。

在HTTP/2中，服务器可以对客户端的一个请求发送多个响应。

在HTTP/1.X，只能通过客户端发起request,服务端才产生对应的response。



## 减少网络流量的头部压缩

HTTP/2：对消息头进行了压缩传输，能够节省消息头占用的网络流量





# 什么是 gRPC - 基于Protobuf 序列化协议 的 RPC 框架

1、高性能，开源和通用的RPC框架

2、基于 Protobuf 的序列化协议开发

3、支持众多开发语言

4、对移动设备更友好，更省电和节省空间

​	面向服务端和协议端

​	基于http/2设计，带来诸如双向流，流控，头部压缩，单TCP连接上的多路复用请求等特性



理念：

定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。

在服务端实现这个接口。

运行一个gRPC服务器来处理客户端调用。

在客户端拥有一个存根能够向服务端一样的方法。



# gRPC 大致请求流程

1.客户端(gRPC Stub)调用A方法，发起RPC调用

2.对请求信息使用 Protobuf 进行 对象序列化压缩（IDL）

3.服务端（gPRC Server)接收到请求后，解码请求体，进行业务逻辑处理并返回。

4.对响应结果使用 Protobuf 进行 对象序列化压缩（IDL）

5.客户端接受到服务端响应，解码请求体。回调被调用的A方法，唤醒正在等待响应（阻塞）的客户端调用并返回响应结果![](..\images\gRPC 大致请求流程.png)



# gRPC 优势



## 性能好

使用有效的二进制消息格式protobuf 进行序列化

序列化之后消息体积小



## 代码生成

.proto 文件 定义了 gRPC 服务器和 消息的约定

从端到端生成消息和客户端代码

创建了强类型的客户端



## 严格规范

规定有关 gRPC 服务必须遵循的格式



## 流

支持所有流组合

​	1、一元

​		一个请求对应一个返回对象

​		标准 RPC 通信

​	2、服务器到客户端流：

​			客户端流式 RPC 客户端传入多个请求对象，服务器返回一个相应结果

​			如：物联网终端向服务器发送数据

​	3、客户端到服务器流：

​			服务器流式 RPC 一个请求对象，服务器可以返回多个结果对象

​			服务器流式 RPC 下，客户端发出一个请求但不会立即得到一个响应，而是在服务器与客户端之间建立单向的流，不断获取响应直到流关闭

​			如：客户端向服务器发送股票代码，服务端把股票的实时数据源源不断返回给客户端

​	4、双向流媒体

​			客户端流式 + 服务端流式

​			可以传入多个对象返回多个响应对象

​			如：聊天应用



## 超时和取消

允许客户端指定等待RPC 完成时间

可以决定超时采取的行动



# gRPC 劣势



## 浏览器支持有限

不能从浏览器调用 gRPC 服务



## 非明文

Protobuf 编码是二进制格式不可读

需要在 .proto 文件中指定的消息接口描述才能正确反序列化



# 使用场景

建议使用：微服务、点对点实时通信、多语言混合开发环境、网络受限环境

不建议使用：浏览器、广播实时通信、进程间通信
