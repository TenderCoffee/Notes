# UDP 特点

1、**非连接** = 传输数据前双端不需要建立连接

​	发送端：UDP发送速度 只会受限于：应用程序生成数据的速度+计算机的能力+传输带宽的限制

​	接收端：把每个消息都放到队列中，每次从队列中读取一个消息段

2、不建立连接 = **不需要维护连接状态（收发状态）**

​	一台服务器可以同时向多个客户端传输相同的消息

3、**包头短**（8字节），开销小

4、吞吐量 **不受拥挤控制算法调节** 只会受限于：应用程序生成数据的速度+传输带宽+源端和终端主机性能的限制

5、UDP虽然无法保证可靠数据交付，但也**不需要维持许多参数的复杂的链接状态表**

6、面向报文

​	发送端的UDP在添加包头后就交付给 IP层 不做拆分和合并，只是保留报文边界

​	应用程序**需要自己限制合适的报文大小**防止因为报文太大导致丢失率高



# UDP 的包头结构

源端口：16位

目的端口：16位

长度：16位

校验和：16位

一共64位 = 8字节

包体长度：2^16-1= 65535 字节





# 为什么选择 UDP

1、面向无连接

**2、系统开销少**

**3、包头小、没有状态、程序结构简单**

4、数据包模式

5、可能丢包

6、不保证数据顺序



只使用一个 Socket进行通信

吞吐量巨大，但需要手动控制丢失率和可靠性



# 什么情况下选择UDP

1、服务器和客户端都可以独立发包

2、无法忍受延迟



# 实现可靠 UDP

UDP = TCP 缩减版

相同点：

​	1、以异步发送和接受的方式进行

​	2、发送和接受 需要缓冲队列

​	3、发送数据需要合并数据包

不同点：

​	1、UDP 需要自己校验重发

​	2、UDP 数据报发送模式丢包概率大、顺序不确定

​	3、UDP 没有连接状态 = 没有断开机制 = 没有连接确认机制



## 修改 UDP 的确认连接机制 - 两次握手

UDP 本身是无状态连接，模仿 TCP 的确认连接机制，让 UDP 更可靠

区别：省去最后一次握手数据



### 握手数据包

​		在确认连接前不进行任何其他类型的数据发送和接收

​		用于确认连接成功与否的数据包



### 两次握手

1、在 UDP 打开连接后，客户端先向服务器发送一个握手数据包

​	代表客户端向服务器请求连接确认信号的数据包

​	仅仅是一个 Seq=0 或其他服务器能识别的带有连接确定信号的特殊字段

​	实现第一次握手

2、服务器 收到 握手数据包后 ，向客户端反馈一个 握手数据包

​	里面也带有客户端能识别的连接确定信号

​	客户端收到后表示 发给服务器端的连接确定数据包 有了反馈

​	第二次握手后双方就表示可以正式成功建立连接

```c#
//1、使用 API 简历 UDP 连接
SvrEndPoint = new IPEndPoint(IPAddress.Parse(host), port);
UdpClient = new UdpClient(host, port);
UdpClient.Connect(SvrEndPoint);

//2、启动接收数据线程
UdpClient.BeginReceive(ReceiveCallback, this);
void ReceiveCallback(IAsyncResult ar)
{
    Byte[] data = (mIPEndPoint == null) ? UdpClient.Receive(ref mIPEndPoint) : UdpClient.EndReceive(ar, ref mIPEndPoint);
    
    if(null != data)
    {
        OnData(data);
    }
    
    if(mUdpClient != null)
    {
        //尝试接收消息
        mUdpClient.BeginReceive(ReceiveCallback, this);
    }
}

//3、发送连接确认数据包 并 屏蔽其他发送和接收功能
SendConnectRequest();	//发送握手数据包
//关闭普通的接收数据包的开关 在连接还没确认前不接收其他形式的数据包 实际上接收数据包仍然继续，只是不加入数据处理队列且不处理数据的具体句柄
StopSendNormalPackage();	
StopReceiveNormalPackage();

//4、等待接收连接确认数据包
void OnData(bytep[] data)
{
    if(!IsConnected)
    {
        if(IsConnectResponse(data))
        {
            //服务器已经收到握手数据包并且做了回应 可以标记为已连接
            OnEvent(Event.ConnectSuccess);
            IsConnected = true;
        }
        return;
    }
    ProcessNormalData(data);
}

//5、开启正常发送和接收数据包的功能
void ProcessNormalData(data)
{
    if(!IsConnected) return;
    //开始数据包的处理过程：识别、装载、推入队列、检测是否丢失、是否需要重发 等等
    DealNetworkData(data);
}

```



### 断线检测 - 心跳包

UDP 是 无状态连接：打开=完成连接 关闭=断开

持续的心跳包：

​	客户端 - 每隔多少秒发送一个心跳数据包给服务器，心跳包包含了一些客户端信息（ID、角色状态、设备信息等）

​	服务端 - 收到客户端发的心跳包后，也回复一个心跳回应包（包含服务器当前时间、服务器当前状态）

​	收到 = 连接中

​	指定时间内没收到 = 断开 = 客户端重连程序



## 数据包 校验与重发 机制

Seq：源端的发送序列号

Ack：目的端的接收确认序列号



TCP 接收和发送累计大小的 检测方式使得重传量比较大，失败就需要整个数据重传，重传内容太多，无法准确定位重传的数据包，如果丢失的是中间的数据包，已经到达的数据也需要重传，TCP 的可靠性依赖于大量的带宽消耗。



UDP 对 TCP 的重传改进：

**新增队列：已经发送但还没有确认的队列**



**机制：Ack 确认 + Seq**

1、A端 向 B端 发送数据包，数据包中包含 Seq=1，发送后将这个数据包推入已经发送但还没有确认的队列里

​			Seq=1

​	如果 B端 接收到 Seq=1 的数据包，就回应 A端 一个确认包，包中 Ack=1 表示 Seq=1 的包已经确认收到

​			Seq=1 Ack=1

​	如果 B端 没有接收到 Seq=1 的数据包，A端 n秒 后没有收到 Seq=1 的确认包，则判定 Seq=1 数据包传输失败

​	从 已经发送但还没有确认的队列 中取出 Seq=1 的数据包，重新发送

2、A端 向 B端 发送10个数据包

​		Seq=1、2、3、4、5、6、7、8、9、10

​	服务器收到的序列是

​		1、3、4、5、7、8、9、10

​	2 和 6 没有收到数据包

​	A端 在 等待确认数据包超时后，对 2 和 6 重传

​	B端 接收到数据包后，处理数据包时，如果数据包顺序有跳跃的现象 = 数据包丢失 = 等待A端重传 = 在断开的序列处停止处理数据包，等待重传数据包

3、加快丢包重传的确认速度：

​	A端 向 B端 发送 5个数据包 

​		Seq = 1、2、3、4、5

​	B端 收到的包的序列是 1、3、4、5

​	收到3 的时候 发现2被跳过1次，收到4的时候发现2被跳过2次

​	B端 立刻向 A端 发送确认包要求 启动2 的数据包的重传



## UDP 的丢包 分析和解决

1、接收端处理时间过长导致丢包

​	异步接收数据方法接收数据时，处理数据会花费一些时间，处理完后如果再次调用接收方法，那么在两次调用的间隙里发过来的包则有丢失的可能

​	解决：

​	方法一：在接收端中，将接收到的包存入一个缓冲区，并迅速返回继续开启接收线程

​	方法二：双队列机制缩短锁队列时间，消除处理数据包和接收数据包的线程之间的冲突

2、发送的数据包大，导致丢包的概率加大

​	MTU：网络上传送的最大数据包

​	解决：

​	控制报文大小限制在 1500byte 内（以太网的 MTU = 1500byte）

3、发送包的频率太快

​	UDP 的发送数据不会造成线程阻塞，发送接口是异步的，不保证当前执行下一条语句时前面的数据已经被发送。在缓冲区满的瞬间要发送的报文有可能丢失，可能出现一秒发送成百上千的数据包。

​	解决：

​	建立 Socket 接收缓冲队列 或 发送缓冲队列，并且在发送频率过快的时候考虑线程 sleep 休眠作为时间间隔

​	



# 可靠 UDP - KCP

UDP 使用在 实时性高、不需要一直保持长连接 的场景下

TCP 流式传输，UDP 报文传输

​	流式传输：连续，每次读取都是可以延续上一次继续往下读，不会丢

​	报文传输：每次只能读取一个报文，假设包体大小是 1400的大小，而最高只读1000，则400会丢失

UDP 发送的时候 不能超过 MTU（最大传输），接受的时候要一次性读取完整个包

MTU：数据帧长度必须在 46-1500 字节之间，1500 被称为 MTU

**单个UDP最大内容是 1472（1500 - 20 - 8）**

​	20字节：IP报文 头部

​	8字节：UDP报文 头部

注意：因为 运营商 PPPOE 协议（模拟机的 NAT 模式），也会占据一定的字节，所以不能直接卡住使用 1472，可能会出现在局域网正常发送报文，但在公网中发送丢包的情况，

​	游戏带宽优化MTU，推荐使用 **500+** 即可。

​	音视频带宽优化MTU，推荐使用 **1400** 即可。



TCP 重传机制不可控，UDP 可以自己实现重传机制



可靠性传输：

**1、绝对可靠：**

**2、尽量可靠：允许丢包**

​	如：英雄走位，如果使用绝对可靠，在网络环境不好的情况下快速修改走位的目标点，可能会因为一直重传丢失的包的原因，导致卡住后面的操作，这时候不如直接忽略没有反应丢失的包，直接发后面的包



UDP：无连接、面向消息

1、数据包容易丢失 -> 数据收到确认机制 + 超时重传机制

2、数据包无序 -> 重排机制（头部 + 排列序号）



模仿TCP 增加一个头部 加上序号

![](.\images\KCP_1.png)



## KCP 内部实现 - +++++++TODO

https://github.com/KumoKyaku/KCP



# UDP 协议的优点

1、灵活的优化网络协议

2、有些消息从设计上就允许丢包情况出现

3、可以根据前后两帧消息猜出中间帧的消息



# UDP 协议的缺点

不可靠

## 1、数据包重复

​	数据包从客户端发到服务器之间会经历 N 个路由器，可能中间某个路由器就对数据包进行了复制，服务端可能受到2个相同的数据包

​	解决：每个数据包自带一个**自增并且唯一的序列ID**，收到消息的时候进行比较，如果之前已经有收到相同ID的数据包，则无视这个新收到的数据包



## 2、数据包错序

​	客户端一次发送了数据包A和数据包B，但是服务器先收到了 数据包B，之后收到了 数据包A

​	解决：

​	1、 每次收到消息都能收到 **对方上一次发送的序列号的ID**，下次自己向对方发送消息的时候，把这个序列ID也带上发给对方，这样对方就知道消息是否发生了错序

​	2、 发生错序后，需要进行 **消息的重排（重新排序）**



### 数据包重新排序

  		1. 每个消息会额外发送一个 16位的掩码 （AckMsk）
  		2. 16位掩码记录了16个消息是否已经完全收到（1=收到 0=没收到）



## 3、数据包丢失

​	客户端依次发送数据包A和数据包B，但是服务器只收到了 数据包A 并没有收到 数据包B





# 可靠UDP







# NetCode

![](images\NetCode前后端预测减少传输量_服务器接收.png)

![](images\NetCode前后端预测减少传输量_客户端接收.png)



延迟补偿：需要考虑发送消息的时间

前后端向对方发送消息，在 T1 时间发送消息，T2 时间 对方才收到消息

需要对时间进行延迟补偿，在真正发生的时刻进行计算从而去预测

![](images\NetCode延迟补偿.png)
