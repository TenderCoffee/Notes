# TCP 协议的可靠性

数据可靠 但是会带来更大延迟

出现数据包丢失、错序、复制的时候，TCP的 Steam 就需要停止等待



# TCP：传输层 面向连接的协议

在收发数据前，必须跟对方确认已经建立可靠的连接



SYN标志位：

​	=1，表示建立TCP连接；

ACK标志位：

​	验证字段，对数据确认

seq标志位：序列号

FIN 标志位：终止这个方向的连接 

​	只意味着这一方向上没有数据流动

​	一个TCP连接在收到一个FIN后仍能发送数据



![](.\images\TCP.png)



# TCP 三次握手 - 确认建立可靠连接

1、主机A 向 主机B 发出连接请求数据包 - SYN（synchronize）标志的数据包

​	**Syn=1 seq=x**

2、主机B 向 主机A 回传一个带有 SYN/ACK 标志的数据包传递确认信息

​	**Syn=1  Ack=x+1 seq=y**

3、主机A 再发出一个带有ACK标志的数据包 确定主机B 的要求同步

​	**Syn=1 Ack=y+1 seq=x+1 **



## 为什么是三次握手

可用性、安全性、效率

三次握手的重要目的：同步初始序列号



如果是 **四次握手**（2和3 都是 B 给 A 发包 可以合并成一个）

1、A 发送 同步信号 syn + A的初始 seq 序列号值

2、B 确定收到 A的同步信号，并记录 A的 初始序列号记录到本地，命名为 B 的 Ack 序列号值

3、B 发送同步信号 syn + B 的初始 seq 序列号值

4、A 确定收到 B 的同步信号后，记录 B 的初始序列号记录到本地，命名为 A 的  Ack 序列号值



如果是 **二次握手**（A 和 B 就 A 的初始序列号打成一致，但是B无法知道A是否已经接收到自己的同步信号）

1、A 发送 同步信号 syn + A的初始 seq 序列号值

2、B 发送同步信号 syn + B 的初始 seq 序列号值 +  B 的 Ack 序列号值

二次握手无法验证客户端真伪，对每个进来的连接都要分配连接资源（无法防范DDos攻击）



可用性：

​	四次握手：也可以达成握手，但中间两次握手可以合并成一个

​	两次握手：可以完成初始序号，但无法完成同步的目标

​	三次握手：可以防止旧的重复连接造成混乱，比如三次握手可以保证 旧的syn 比 新的syn 先到达服务端



安全性：

​	防范DDos攻击



效率：

​	三次握手比四次握手效率更高





# TCP 四次挥手

全双工 = 每个方向都必须单独进行关闭

1、主机A 将控制位 FIN=1 = 停止TCP连接请求

​	主机A 进入 FIN_WAIT_1状态

​	**FIN=1 seq=x**

2、主机B 收到 FIN为1 的信息后，确认 即将这个方向上的 TCP 连接关闭，Ack =1

​	主机A 知道自己发送的 TCP 断开请求得到验证

​	**FIN=1 Ack=x+1 seq=y**

3、主机B 在确保断开前 所有传输到主机A 的数据是否已经传输完毕

​	确认传输数据完毕后 将回复报文的FIN=1 发给主机A，并关闭连接

​	z = 主机B随机生成

​	**FIN=1 Ack=x+1 seq=z**

4、主机A 对 主机B 进行确认，Ack=1， 并关闭连接

​	h = 主机A随机生成

​		**FIN=1 Ack=z+1 seq=h**

至此双方关闭连接



# TCP 包头结构

源端口：16位

目标端口：16位

序列号（Syn）：32位

回应序号（Ack）：32位

TCP 头长度（head size）：4位

保留（reserved）：6位

控制代码：6位

窗口大小（size）：6位

偏移量：16位

校验和：16位

选项（可选）：32位



TCP包头 最小长度：192-32=160位=20字节（160/8）



# TCP 包体

包头结构中，窗口大小位置上的数据决定 具体 包体的数据空间

单个数据包最大承载：2^16 -1 = 65536 字节数据





# TCP 检测丢包和丢包处理



## Seq+Ack - 判断丢包

发送方通过ack 的值知道接收方接收了哪些 seq 的包

检测丢包：

1、定时器检测：超时没有收到 Ack确认应答报文 = 需要重发

2、如果发送端在 Seq2 后的其他 Seq的回复中，收到多个相同的Ack=2 的确认，则说明接收端没有收到 Seq2 = 需要重发

3、SACK 选择性确认

SACK 可连续接收发来的报文 = 已经接收的报文

Ack = 待接收的报文

**ACK到SACK之间** 就是需要进行重发的数据范围

4、Duplicate SACK

主要是针对ack丢失的情况和网络延时的情况，SACK有不同的表示方式。



## 如何减少丢包

不需要每一个包发送之前都需要上一个包的Ack返回确定，效率很低

发送方在等待Ack的同时没有必要停止后续包的发送



发现丢包后，根据最近收到的Ack 根据策略重新发送序列号后丢失的分包

发送方需要缓存已经发出但是没有收到Ack 的包

接收方收到包但没有把包交给用户进程之前也需要把收到的包先缓存起来 

缓存有大小限制，发送方 和 接收方 限制可发送和可接收的数据最大范围



## 减少丢包：滑动窗口-接收方窗口（rwnd）

**滑动窗口：根据接收方的接纳能力，来决定发送方的发送数据的能力**

**接收方决定了滑动窗口的大小**



通过滑动窗口进行流量控制

**AdvertisedWindow**：接收方发送给发送方的 TCP头部的 Window Size

发送方根据这个值决定发送方滑动窗口的大小



使用场景：

发送端发送的数据很快 + 接收端接受速度慢 = 数据更容易丢失

解决：

流量控制，控制好通信双方工作节奏



接收端能提供的缓冲区大小是有限且变化的



TCP 滑动窗口值 = 发送端对发送的数据能提供多大的缓冲区

16位 = 最大提供 65535字节的缓冲



### 接收方滑动窗口

![](.\images\TCP 滑动窗口.png)

已接收已确认：已经收到 并且 已经成功发送Ack

**等待接收未确认**：还没有给对方回应 Ack，**真正的接收方的缓存大小**，这一部分缓冲区的大小，是接收方的有效缓冲区，接收方的通知窗口大小

不可接收：还没接收也没办法接收的分包，超出接收方的能力



**接收方的 有效缓冲区**：等待接收未确认 - 真正的接收方的缓存大小，接收方的通知的窗口大小



### 发送方滑动窗口

![](.\images\TCP 滑动窗口_2.png)

已接收已确认：已经发送完毕的网络包。可回收

**已发送未确认**：发送方需要等待，如果发送不成功，还需要重新发送

**未发送可发送**：接收方空闲的能力，可以马上发送

未发送不可发送：超过接受方的接收能力，如果发了接收方也接收不了



**发送方的 有效缓冲区**：已发送未确认 + 未发送可发送，发送方的窗口大小



## 减少丢包：拥塞窗口 - 发送方窗口（cwnd）

**在 发送端 定义**，只是发送方的一个内部参数，又名 cwnd

用来处理网络拥堵情况

具体做法：发送端 最大的发送范围是拥塞窗口 和 滑动窗口 中较小的一个，即 Min[rwnd, cwnd]

拥塞窗口会动态根据网络情况的变化而进行调整

如果没有出现拥塞，就扩大拥塞窗口大小，否则减少拥塞窗口大小

拥塞窗口一般都小于 滑动窗口 的值

![](.\images\TCP 拥塞窗口.png)



拥塞避免：指数增长 => 线性增长

在窗口大到一定程度以后（达到 慢启动门限 ssthresh），减少增加的速度，转成线性扩大窗口的方式，也就是每次收到新的 Ack 没有丢包的话，只比上次窗口增大1



线性增长 也会随着增长 碰到 拥塞窗口的极限（CWND）出现丢包

出现丢包后，会根据算法，减少拥塞窗口从而让网络可以缓过来





# TCP 粘包

产生原因：TCP 基于字节流

二进制数据没有边界

字节流数据会被切割和组装成各种数据包 = 无法还原 = 出现粘包



谁导致了粘包：

1、发送端组装消息把几个小包合成一个

2、接收端接收消息后，会有接收缓冲区的存在

​	两条独立的消息进入缓冲区间隔太小，接收端的应用层在两次消息同时读取了两条消息

![](.\images\TCP粘包.webp)



解决粘包：

1、在信息中加入特殊的标志 - 分隔符

​	出现的错误：消息内容和和分隔符重复导致分割出错

**2、约定信息长度**

​	先根据消息长度字段读取长度信息

​	用长度信息读取消息内容

**3、包首部**

​	包首部有数据包的长度



# 为什么选择 TCP

1、基于连接

2、系统开销较多

3、包头大、有各类状态、底层结构稍微复杂

**4、流模式**

**5、保证数据正确**

**6、保证数据顺序**



TCP 底层已经做了数据包切分，数据包大小没有限制，不需要切分数据包

需要为每个客户端简历一个Socket连接

TCP 发生丢包会出现巨大延迟：

​	需要检测哪些包会丢失再重发直到被接收到为止



# 什么情况下选择TCP

1、服务器和客户端都可以独立发包

2、偶尔发生的延迟可以容忍



# 程序实现TCP长连接

**1、建立连接**

​	TCP底层有数据包可靠性确认 和 丢包重发机制 = 不需要实现包的校验、拆分、重发

​	建立连接、发送、接收：

​		BeginConnect、BeginReceive、BeginSend、BeginDisconnect、Disconnect	

​	

​	线程锁 lock：解决 主线程 和 子线程 资源抢占冲突



**2、断线检测** 

## 心跳包

​	TCP ：强连接有自己的检测机制，但有时候因为网络导致断线判断不及时

​	解决：**服务器 向 客户端发送 心跳包 协议**

​	心跳回应包内包含客户端的少量信息，例如，客户端状态、用户信息等

​	服务器指定多少秒内没有收到 反馈心跳包信息 = 断线



​	断线重连后的数据处理：

​		传统 TCP：断线时数据缓存中的数据丢失，重连无法重发数据包



## 缓冲队列 - 存储 和 缓冲，解决断线重连数据丢失

​		发送数据会瞬间积累很多需要被发送出去的数据包

​		在断线重连时重发数据包

​	接收数据包的缓冲队列：

​		1、让负责接收的子线程将接收好的网络包放入接收缓冲队列，数据包不会按照希望的大小发送，需要解决粘包问题

​		2、由主线程 通过 Update 轮询检查接收队列是否有数据包，有则一个个取出来处理，否则继续轮询等待

​	

​	缺点：

​		效率不够高，多线程因为锁的效率而让线程处于等待状态，被卡住，其他线程无法继续工作

​		主线程处理响应数据逻辑，需要花很长时间处理网络数据再反映到画面上。

​		如果接受数据的线程因为接收队列被主线程锁住而不能继续工作去接受数据，就只能等待资源使用结束后才能使用资源

​	**解决：双队列结构**

​	

## 双队列结构：接收数据队列 + 处理数据队列

高效内存数据结构，提升多线程中队列的 读/写 效率，避免共享队列的锁开销

各线程有各自的队列，不需要因为资源锁等待



接收数据线程：

​	接收到数据时直接推入接收数据的队列

主线程 - 处理数据的线程：

​	轮询的时候：

​	1、先将接收数据的队列复制到处理数据的队列中

​	2、清空接收数据的队列

​	3、主线程对复制后的数据队列进行处理，**这时候的子线程无需等待主线程的逻辑处理时间就能继续接收数据**

```c#
//子线程中的接收数据线程
void Receive_CallBack(Data _result)
{
    //只需要将数据推送到接收队列中即可
    Pushdata(_result);
}

//处理数据的主线程
void SwitchQueue()
{
    //只需要在切换的一瞬间锁上资源
    lock(obj)
    {
        //交换队列
        //将接收数据的队列复制到处理数据的队列中
        //清空接收数据的队列
        Swap(receiveQueue, produceQueue);
	}
}

void Update()
{
    //主线程需要处理数据的时候，需要先切换队列，防止对队列占用过多时间
    SwitchQueue();
    //切换完毕后 再对队列中的全部数据进行处理
    while((data = PopQueue()) != null)
    {
        Deal_with_network_data(data);
	}
}

```



**3、网络协议**

数据格式的协定 = 双端交流的语言

​	1、需要双端都接受的格式

​	2、数据包最小化

​	3、要有一定的校验能力 - 解决粘包

​			用包头作为业务层的协议格式

​				1、记录了数据包大小

​				2、记录数据块的标示，确定调用的是哪个逻辑句柄



**把数据包分成头、固定标识信息、数据块：**

​	1、头部存储包括大小、加密位、广播方式等信息

​	2、标识信息则存储例如句柄编号、序列号、特殊命令编号、校验码等的标识信息；

​	3、数据块存储具体的数据信息



TCP 的校验方法：注意性能消耗

​	1、MD5

​	2、奇偶校验 = 异或

​	3、CRC - 循环冗余校验：利用除法以及余数的原理

​	4、加密：RSA、公钥私钥、非对称加密



**4、发送和接收队列缓冲**

**5、发送数据合并**



数据包大小对发送的影响：	

发送数据包太多，短时间内积累过多数据包，导致发送池溢出

数据包太小，每个数据包发送一次，等待接收后再发送，发送效率过低，发送速度太慢，延迟时间变长

一次性发送全部数据，太大导致发送效率低，越大越容易丢包，TCP 全盘否定重发，效率低下

解决：发送队列+发送数据合并



## 建立发送缓冲 - 发送队列+发送数据合并 （TCP可选）

保证发送的有序和高效

​	1、每次调用发送接口时，先把数据包推入发送队列

​			发送程序轮询是否有需要发送的消息在队列里，有就发送，没有就继续轮询等待

​	2、发送时合并队列里的一部分数据包

​			实现一次性发送多个数据包提高效率

​	3、合并限制在窗口大小范围内（2^16-1 字节内）



**TCP 其实可以不用，因为本身有确认和重发机制**



**6、线程死锁策略**
