# 游戏渲染引擎

低阶渲染器 + 场景图/剔除优化 + 视觉效果 + 前端



![](images\游戏渲染引擎.png)



## 低阶渲染器

1. 包含引擎中全部原始的渲染功能，着重于尽可能快、尽可能丰富的渲染几何图元
2. 不考虑哪些场景部分是否可见
3. 包含多个组件



图形设备接口：DirectX、OpenGL、CG、

1. 连接和枚举图形设备
2. 初始化图形设备
3. 建立渲染表面（如后台缓冲、模版）等



## 场景图/剔除优化

1. 限制原始被提交的需要渲染的图元的数量
2. 使用平截头体剔除算法（去除摄像机不能看到的物体）
3. 使用空间分割算法，如 BSP tree（二元空间分割树）等
4. 也可以使用 入口（portal）以及 遮挡剔除（occlusion culling）



## 视觉效果

1. 粒子系统
2. 贴花系统
3. 光照贴图以及动态阴影
4. 环境贴图
5. 全屏后期处理效果，一般在屏外缓冲（off-screen buffer）后使用，一般包括：高动态范围光照、全屏抗锯齿、颜色校正 等



## 前端

1. HUD
2. 游戏内置菜单、主控台、其他开发工具
3. 游戏内置GUI
4. 全动视频（游戏引擎录制）
5. 游戏内置电影



# 渲染管线



## 应用阶段

输入：场景数据、Culling、每个模型的渲染状态（各种Map、Shader以及一些配置）

输出：渲染所需的几何信息

负责：开发者、CPU

主要任务：加载数据到显存、设置渲染信息、发布渲染命令（Draw Call）传递给 GPU

方式：U3D中通过材质球（渲染信息的集合）传递信息

![](images\渲染管线_应用阶段.png)



包含子流程：

 	1. 将开发者设置好的数据加载到显存中
 	2. 设置渲染状态
 	3. 调用 DrawCall（降低 DrawCall 的思路：所有东西打包到一次（打包策略））



CPU：处理逻辑 的优势

GPU：算力 的优势



## 几何阶段

用数学运算，把人理解的3D的信息转换到2D的屏幕上



输入：上阶段输出为此阶段的输入

输出：图元在屏幕空间的顶点信息（坐标、深度值、着色等相关信息）

负责：GPU

主要任务：顶点坐标变换为屏幕坐标，裁剪，屏幕映射

方式：齐次裁剪坐标系转换![](images\渲染管线_几何阶段.png)



包含子流程：

1. 顶点着色器（可编程）
   1. 坐标变换：把顶点坐标从模型空间转换成齐次裁剪空间
   2. 逐顶点光照：计算颜色
2. 曲面细分着色器（可能不存在）
3. 几何着色器（可能不存在）
4. 裁剪（可配置）
   1. 将摄像机视野范围外的物体裁剪掉
5. 屏幕映射（不可配置、不可编程）



## 光栅化阶段



输入：上个阶段输出为此阶段输入

输出：生产屏幕上的像素，并渲染出最终的图像

负责：GPU 负责

主要任务：决定每个图元中的哪些像素应该被绘制在屏幕上

方式：确定顶点形成的三角形边覆盖了哪些像素，形成片元，并且进行计算出具体颜色，并确定哪些片元需要被显示

![](images\渲染管线_光栅化阶段.png)



包含子流程：

1. 三角形边界计算：计算三角网格表示数据的过程叫做三角形设置
2. 三角形遍历：
   1. 检查哪些像素被三角网格覆盖的过程
   2. 检查到一个生成一个片元
   3. 根据三角网格的3个顶点信息对整个覆盖区域的像素进行插值
   4. 输出是一个偏远序列
   5. 片元不是像素，是包含了很多状态的集合，用于计算像素的最终颜色（屏幕坐标、深度信息、法线坐标、纹理坐标等）
3. 片元着色器（可编程）
4. 逐片元操作（可配置）
   1. 输出合并阶段
   2. 决定每个片元的可见性（模版测试、深度测试）

















