# 一般简单的渲染过程

模型 =》 输入结构 =》 顶点 Shader =》 输出结构 =》 像素 Shader =》渲染结果



## 模型

信息：

顶点、三角面、法线、顶点色



模型：obj 资源文件

![](.\images\obj文件.png)

## 输入结构 struct

收集模型信息中可以用到的信息，放入到输入结构中

提供给后续渲染用



```shader
struct VertexInput
{
	float4 vertex : POSITION;
	float3 normal : NORMAL;
};
```



## 顶点 Shader

使用输入结构，得到输出结构



将模型每个顶点位置信息，换算为每个顶点应该在屏幕的位置

计算和赋值其他逐顶点信息，如 UV、顶点色、顶点法线



## 输出结构 struct

```shader
struct VertexOutput
{
	float4 vertex : SV_POSITION;
	float4 posWorld : TEXCOORD0;
	float3 normalDir : TEXCOORD1;
	LIGHTING_COORDS(2, 3);
};
```



## 像素 Shader

前面得到的输出结构 + 自定义材质参数 + 光照环境（Lighting）+ 灯光 + 摄像机 传输给 像素Shader

得到渲染结果



方向光 可以在 顶点和像素 Shader 都可以拿到，引擎传入



# 标量、向量

标量：只有大小没有方向的量

向量：有大小也有方向的量

理论上不存在没有大小只有方向的量，但存在大小无现实意义的量，这时候需要归一化处理



# 点乘：Dot

两个向量之间的一种运算方法，结果为标量

**点乘几何意义**：一个向量在另外一个向量上的投影长度

图形学表现：两个向量点乘  方向相同时=1 方向相反=-1 垂直=0



## **点积Dot 用处1：判断是否受到光照的影响**

光照的**反方向**（LightDir - lDir） 和 模型表面垂直方向的每个法线（法线方向）（nDir） 做一个点乘，点积后 就可以知道是否受到光照的影响

方向相同时=1=白色 方向相反=-1=黑色 垂直=0=黑色

结果：-1 ~1

![](.\images\兰伯特光照模型.png)



## 分支1：兰伯特(Lambert)光照模型 Max(0, nDir · lDir) 处理 负值



负数（-1） 是一个 无意义的亮度，所以会 **将结果为负数的值 都改为 0**，让输出不会有负值

**Clamp(0,1)**

缺点：
不透气，暗面会有死黑的 感觉

结果：0~1



## 分支2：半兰伯特光照(Half Lambert)模型 没有负值且有光感 半:0.5

点积的基础上修改，**乘以 0.5，再加上 0.5**

-1 * 0.5 ~1 * 0.5 => -0.5 ~ 0.5

-0.5 + 0.5 ~ 0.5 + 0.5 => 0 ~ 1

结果：0 ~ 1

![](.\images\半兰伯特光照模型.png)

优点：比 兰伯特光照模型 透气，不至于 暗部死黑

缺点：和美术素描的表现不一致



## 映射 - 得到假SSS的透光效果

两个集合，元素之间的相互对应的关系



半兰伯特光照模型：0~1 黑色~白色

渐变调色：0~1 纯红色~黄色

![](.\images\调子映射.png)

半兰伯特光照模型的调子视为 UV 坐标的 的 U坐标

再附加一个**常量作为 V 坐标**（因为v值多少不影响结果），得到 UV 坐标对 RampTex 采样

![](.\images\RampTex.png)

RampTex 文件设置：

![](.\images\RampTex 文件设置.png)



# Halftone - 半色调（网目调）

通过圆点的密集程度和大小做明暗

印刷品：黑白用圆点做明暗，彩色用不同颜色的圆点做颜色处理





# 技巧



## 可以偏移的 兰伯特

兰伯特偏移 = 法线向量/光照向量 Add 偏移值

![](.\images\可以偏移的兰伯特.png)

Add 偏移量



## 聚集的高光点 没有过度效果

![](.\images\在高光点上追加高光.png)

if > 0.8 = 1 else = 0

非黑即白

![](.\images\在高光点上追加高光_2.png)



## 两个高光点同时存在 合并 - Max

两个值输出，一个值单独输出自己的一个高光点，对于这个值而言，另外一个值的其他区域是非高光点

哪个值更大就用哪个
![](.\images\Max.png)

Max = 黑的地方还是黑的，但A 和 B 所在位置的白的地方 就会是 白的 = 实现了 Combine 合并的效果

![](.\images\两个高光点同时存在.png)

因为点乘 会有 负值的存在，为了安全起见使用了 Clamp 限制 0-1



## 蒙板 - Lerp

![](.\images\Lerp.png)



## Fresnel - 菲涅尔

Exp - 控制 菲涅尔 的范围

菲涅尔：光滑表面，视角越平越容易反射远处的东西，物体边缘会有一层发亮的东西



垂直湖边可以看到湖里自己的脚 - 有些透明

平视看湖里的水 - 反射天空

![](.\images\菲尼尔.png)

### 让 菲尼尔 带有颜色：Multiply - 相乘



## 混合 - Blend

![](.\images\Blend.png)



## ScreenPos - 以屏幕作为UV坐标（屏幕UV）

把一张图赋值给 UV = 显示器全屏是这张图

图片会根据显示器长宽压扁

图会跟着展的UV 走，根据屏幕位置走，赋值的图片不会跟着模型的移动而贴着走

Tield = 平铺

![]()![ScreenPos](.\images\ScreenPos.png)



## Depth - 模型距离摄像机远近的值

距离越近 - 偏黑一点，距离越远 - 偏白一点

Multiply 乘以 Depth  = 格子的间隔会随着摄像机距离的远近变化

让人感觉图片是依附在模型上，而不是屏幕上



## Step - 类似于 if 语句

A <= B 输出 1 白色

A > B 输出 0 黑色



## Frac - 取余 去掉整数部分

1.5 => 0.5



# 常用技术



## ToonShading 卡通

暗部亮部都是平涂的颜色



## HatchingShading

暗部给一些网格点或者手绘排线的效果
