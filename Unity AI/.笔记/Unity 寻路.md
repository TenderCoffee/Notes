# A星算法

**使用贪婪法快速寻找到通往目的地的路径**



目标：最快速度找到通往目的地的路

算法时间平均复杂度 O(N lgN)

最差：全部格子都走一遍



## 少障碍 A 星寻路

假设：其实点为 s，目的地为 e

1、周围4个点加入列表（4个点标记为1）

2、在列表中找到与目的地e距离最短的点（open队列到e的距离从小到大排序）

3、将这个点移除出列表

4、以这个点为基准继续向前探索，直到寻找到目的地为止（从第2步中的最短距离的点周边取出没有标记的元素标记为2，依次重复操作）

5、所有被标记过的不能被重复标记



![A星寻路路径标记](images\A星寻路路径标记.png)



## 多障碍 A 星寻路

假设：其实点为 s，目的地为 e



![多障碍A星寻路路径标记](images\多障碍A星寻路路径标记.png)



代码：

1. 创建双队列：

   	1. open队列：被选中过的点的周围的点，并且这些点没有被取到锅
	
   	1. close队列：已经被遍历过的点，即到达目的后，close队列中存放的就是从起点到终点的路径

2. 把起点放到 open队列中开始循环，将最头上的数据推出来

3. 判断这个点的周围四个点是否已经“踩”过

4. 如果没有被“踩”过，就放入到 open队列视为可选的节点标志

5. 将当前被推出来的点标记为被踩过的点

6. 将整个 open队列进行排序并继续循环



## 缺点

1、**只选择了当前最优路径，但忽视了全局的最优解**，出现了“走弯路”

2、大场景中 普通A星 消耗较多 CPU（open队列会不断加入可行走的点，排序越来越慢）



## 大场景下的 A星算法 的优化



### 长距离导航的优化 - 使用 多段短距离的离线导航点

距离越长被塞入open队列的节点越多，排序速度越慢



大型 RPG 游戏类型：

1、寻路中实时计算的一大部分转化到线下计算并存入到数据文件中，需要寻路到某个节点的时候，从已经计算好的点对点数据中寻找起点和目的地最近的数据。

2、将找到的这段路径取出直接使用



缺点：离线计算也会浪费大量时间

解决：短距离导航点拼接为长距离路径

寻路的时候，先找到最近的导航点，再从导航点触发寻路到目的地附近导航点的导航路径



### 排序算法的优化 - open队列使用最小堆数据结构 + 二分查找插入

修改前：

​	open队列每次插入新的点后，就不再是有序的队列，每次取最小值都需要重新排序

​	元素插入复杂度： O(N lgN)

修改后：

	1. open队列改为最小堆数据结构，不需要每次循环结束时重新排序，而是在节点插入最小堆数据结构进行调整
	1. 二分查找：元素插入队列的时候每次插入复杂度是 O(lgN + N)，



最小堆数据结构：完美二叉树结构

每个父节点都比子节点小，根节点是最小的元素，每次插入或删除会重新寻找最小预期值的节点放到根节点上

插入和删除算法的时间复杂度为 O(lgN)

伪代码：

```
function find_path(s, e)
{
	//最小堆
	open = new MinHeap();
	//已经被取过的点
	close = new List();
	plist = new List();
	
	//从s点开始
	open.add(s);
	//将s加入 close 队列
	close.add(s);
	
	//重新遍历直到没有点可以取
	for(!open.IsEmpty())
	{
		//把最近的点推出来
		p = open.pop();
		if(p == e)
		{
			//找到终点
			break;
		}
		
		//取左右上下的点
		p1 = p.left();
		p2 = p.right();
		p3 = p.top();
		p4 = p.down();
		
		plist.Clear();
		plist.add(p1);
		plist.add(p2);
		plist.add(p3);
		plist.add(p4);
		
		for(int i = 0; i < plist.Count; ++i)
		{
			pp = plist[i];
			if(null != pp && pp.IsNotInClose())
			{
				//期望值为到终点的最短距离
				pp.f = dis(pp, e);
				if(pp.IsNotInOpen())
				{
					//设置已经在 open 中
					pp.SetOpen();
					//加入最小堆
					open.Add(pp);
				}
			}
        }
        
        //p点已经被取过
        close.add(p);
	}
	
}
```



### 寻路期望值优化 - 实时计算期望值

之前：当前点p 和 终点e 的距离 太接近了终点，open队列加入比预期更多的节点导致排序速度慢

解决：

​	F（期望值） = G（当前最少步数，即 起点s到当前点p的最小步数） + H（当前点到终点的最短距离 即 当前点p到终点e的最短距离）

​	实时计算期望值，每次提取临近的可行点位时计算一个期望值，从而了解该点通向最终目标点的预期



期望值计算公式：

1、如果公式只关注离终点距离最近的点位，那么在寻路过程中选择点位的顺序就会偏向离终点更近的点，无论最终能不能到达终点，只要它靠近终点就行，但通常地图中有很多点位很靠近终点却无法到达终点。

2、如果公式关注的是**从起点到终点整段距离最小的点位**，那么寻路过程中在选择点位时也会偏向整条路径最短的方向，这间接加快了寻路的速度，即能最快找到到达终点的点位。



伪代码：

```
function find_path(s, e)
{
	//最小堆
	open = new MinHeap();
	//已经被取过的点
	close = new List();
	
	//从s点开始
	open.add(s);
	//将s加入 close 队列
	close.add(s);
	
	//重新遍历直到没有点可以取
	for(!open.IsEmpty())
	{
		//把最近的点推出来
		p = open.pop();
		if(p == e)
		{
			//找到终点
			break;
		}
		
		//取左右上下的点
		p1 = p.left();
		p2 = p.right();
		p3 = p.top();
		p4 = p.down();
		
		plist.add(p1);
		plist.add(p2);
		plist.add(p3);
		plist.add(p4);
		
		for(int i = 0; i < plist.Count; ++i)
		{
			pp = plist[i];
			if(pp.IsNotInClose() && p.g + 1 + dis(pp,e)<pp.f)
			{
				pp.g = p.g + 1;
                pp.f = pp.g + dis(pp,e);
                if(pp.IsNotInOpen())
                {
                    pp.SetOpen();       // 设置为已经在open中
                    open.Add(pp);       // 加入最小堆
                }
                else
                {
                    open.Update(pp);    // 更新最小堆中的节点
                }
			}
        }
        
        //p点已经被取过
        close.add(p);
	}
	
}
```



### 权重引导寻路方向 - 网格中加入权重值改变期望值

期望值 所代表的通向目的地的方向越准确，寻路算法的效率越高，寻找到路径的速度也就越快

F（期望值） = G（当前最少步数，即 起点s到当前点p的最小步数） + H（当前点到终点的最短距离 即 当前点p到终点e的最短距离） + E（格子的权重值）



越小的权重值，在 open队列中会越靠前，更容易被算法取出成为路径搜索方向

权重值 类似于 阻力值 的存在 



### 拆分寻路区域 - 拆分出多个无障碍的凸多边形区域 + 记录区域之间连接点，减少搜索次数

减少点对点的寻路：必须保证拆分的可行走区域是凸形，区域内就不需要再寻路，任意两个点可以直达没有障碍物

寻路的时候只要知道区域是怎样的路径，就能根据区域之间的连接点拼出格子路径

**在三角形网格地图上使用较多**

三角形网格算法： RecastNavigation Navmesh



缺点：

1、动态添加或更改障碍物导致区域重新计算分区

2、拆分区域算法对不同区域的算法不同（如 栅格地图 和 三角网格地图拆分区域算法不同）



### 细节优化

判断节点是否存在：

​	不使用遍历队列，浪费 CPU

解决：	

​	改变判断方式：用整型比较来代替布尔型变量的初始化节省初始化操作

​	1、在寻路类中设置一个属性变量或者专门为寻路服务的静态变量（FindIndex）

​	2、直接把节点做成实例，每个寻路节点中也保存整型变量 FindIndex

​	3、每次调用寻路先对静态全局变量 FindIndex + 1

​	4、节点实例中的 FindIndex 这时候出现了不一样的情况

​	5、用 IsClose 变量判断是否已经被取过 的时候，如果节点实例中 FindIndex 相等，说明已经被当次寻路算法取出过，否则说明节点没有被取出过

​	6、节点取出时候，将 节点实例中的 FindIndex 设置为当前寻路类中的全局 FindIndex 值，表示该节点已经被这次寻路算法计算过



# JPS - A星变种：寻路规则优化使用拐点

A星：逐步扩大搜索范围，同时慢慢接近终点

JPS：在寻找相邻点时候只找拐点（跳点），对其他不感兴趣，更快接近目的地

![](images\拐点.png)



JPS 专门为栅格地图定制：

从八个方向寻找拐点

定义一：强迫邻居

1、如果节点a是b的邻居，且节点a的邻居有阻挡，parent(b) 是路径中b的前一个点

2、并且parent(b)、b、a的路径长度比其他任何从parent(b)到a且不经过b的路径都短，则a为b的强迫邻居，b为a的跳点。

定义二：跳点

1、如果a为起点或终点，则a为跳点。

2、如果a有强迫邻居，则a为跳点。

3、如果从parent(a)到a为对角线移动，并且a经过水平移动或垂直移动可以到达跳点，则a为跳点。



JPS 优化：

1、通过位运算加速寻找跳点

2、通过剪枝优化掉不必要的中间跳点等



JPS 寻路 总过程：

1、从s位置出发，先从1方向寻找跳点，

2、没有找到，再从2方向开始寻找，还是没有找到，

3、最后从3方向寻找，此时找到了跳点，将该跳点推入open队列。

4、由于open队列中只有1个跳点，因此继续从3跳点开始寻找，先从4方向寻找跳点，没有找到，

5、再从5方向寻找跳点，也没有找到，

6、最后从6方向寻找，此时找到了跳点，将该跳点推入open队列。

7、由于open队列中只有6这一个跳点，因此在推出6这个跳点后，只在7这一个方向找到了终点

8、此时结束寻路算法

![](images\JPS算法.png)



# 寻路网格

二维数组：每个元素代表一个可行走的位置

0 = 无障碍

1 = 有障碍

需要和地图尺寸匹配

如果地图很大，数组很小，就无法实现细腻的路径与障碍，数组内存占用量大 和 寻路细节 之间权衡



## 编辑器 - 可视化

### Excel



### 地图编辑

在具体的3D场景地图上实现编辑：

1、把整个地图加载并渲染到画面上

2、在地图上使用颜色方块画出不同颜色的块状

3、编辑地图障碍数据 和 可行走区域



### 地形贴图

跟地形高度图一样，用一张图来存储障碍数据

如：

1、1024x1024 或 其他规则 的像素图代表地形大小

2、每个像素点 代表二维数组的一个元素

3、颜色表示是否可行走（ 255,255,255 = 白色可行走 0,0,0 = 黑色不可行走）

4、将图片压缩成只有RGB的8比特的图

5、不同的元素使用不同的颜色表示



### 使用一维数组代替二维数组

一维数组在分配内存块时候的紧凑度比二维数组更好

一维数组读取索引中的数值会更快，用一维数组取代二维数组不再需要内存地址的跳转，提高指令缓存命中率，加快指令运算速度

二维数组[a,b] = 一维数组[a×width +  b]



## 路点网格编辑器

出现的原因：

1、二维数组构建寻路数据数组太大，编辑的时候要把所有障碍点设置一次工作量比较大

2、场景中部分空间障碍不规则和不密集的时候会浪费很多内存



解决：路点系统

1、将路点放到地图中 并 为每个路点标记ID 以及与路点相连的数据

2、设置路线：为路点配置连线



优点：

路点比其他方式的网格少，内存消耗和CPU 消耗少



缺点：

1、大范围设置可行走区域时需要大量工作编辑可寻路的路点信息与连线

2、无法识别碰撞只能用路点的形式绕过障碍

3、大块空地的寻路需要添加比较多的点才能平滑适应各种寻路路径



路点和路线 + A星算法 来寻路



### 平面三角形网格 - 切耳算法自动生成网格

切耳算法：构建简单多边形的三角化



1、多边形中镂空的情况，需要把镂空的部分加入外围简单多边形

2、镂空之中还有单独的多边形，需要单独拿出来计算三角化部分



算法自动生成网格，无需手动编辑就可以避开障碍区域



找出可行走的三角形网格：首先找出最外围的简单多边形 以及 可行走的镂空之中的多边形

找出后使用切耳算法生成可行走的三角形网格

总流程：

1、根据地形生成相应可行走的三角形网格

2、读取地图中的可行走区域的网格以及障碍物网格，将这些网格数值方向 y轴的值忽略

3、通过多边形合并算法将这些合并为最外层的多边形

4、裁切掉那些一半在里面的情况

4、将最后筛选后的数据使用切耳算法处理得到具体的三角网格



### 多层级2D网格

常用在 2D RPG 游戏

1、把所有可行走的区域分成多个层级

2、每个层级有自己的网格数据，

3、需要对层级之间的入口区域进行记录（触发 = 上升一层 或 下降一层）

4、层与层之间有个中间连接层（概念类似于 楼层之间的楼梯）

5、将中间层的数据单独拆分出来成为独立的层级



优点：遍历高效：寻路的时候只关心当前层的数据，以及当前层和上下两层的数据



每次跨层级寻路的时候都要先寻找上下楼的衔接区域



### A星寻路 + 网格数据



二维数组结构下：

A星算法中的期望值：方块之间的距离



平面三角形网格：

1、使用邻边中点计算路径更平滑

原因：虽然知道路径上的三角形，但是行走的路径如果定位在三角形中心点，行走路径比较诡异（需要先到达三角形中间点后才能去下一个三角形导致中点和中点连线路径不平滑），用边的中点记录路径（因为相邻三角形之间的穿越都是靠邻边来实现）

2、拐点路径算法优化寻路后 的路径（射线优化路径算法）





# 体素化寻路网格 - 3D高度上自由寻路



## 体素化 - 三维数组

本质：把二维数组变成三维数组

1、将空间分割成一个个的立方体小方块

2、每个立方体标志着可行走状态：人物体积无法通过狭窄的门缝或者矮小的洞穴



体素化的缺点：三维数组的可行走关系需要申请很大一块内存

解决：

因为大部分空间无障碍，所以只记录小部分空间障碍，对空间进行拆分



## 八叉树数据结构 - 判断障碍 - 树形 O(lg N) 

1、将空间分成均等的八块

2、将每块中障碍物的部分拆分成更小的八块空间，

3、确保八块空间能够被障碍物填满



树形结构查找效率：O(lg N) 在大型网络游戏中属于低效



## 区分对待寻路区域 -  数组 O(1) - 解决八叉树效率问题

1、地面作为独立的一块寻路

2、地面以上作为另一块内容

3、对不同区域的网格进行分块，每个方块都有是否可行走的标记

4、游戏中大部分区域没有建筑物，这些区域不需要任何数据

5、非地面区域障碍物也要作为一个二维数组：需要记录Y轴方向上的障碍物高度，以及不同障碍物高度的起点和终点



解决后：数组索引 = 查询效率 O(1)

大大降低内存消耗



## RecastNavigation NavMesh

扫描、制作 三角形寻路网格

体素化算法 + 区域划分算法 + 多边形轮廓构建算法 + 轮廓分割成凸多边形算法 + 三角剖分算法



1、体素化：

​	把空间分割成三维方块，每一块都是立方体，每个立方体都有是否可行走标记

**2、生成区域 （RecastNavigation NavMesh最关键的部分）**

​	生成区域的时候对不可行走的区域过滤（障碍物、障碍物周边角色宽度的体素部分、邻接体素的高度不符合要去的部分、邻接有空心体素的部分 等）

**3、拆分区域为多个凸多边形 （RecastNavigation NavMesh最关键的部分）**

​	将上下左右连续的体素进行识别并进行分割成不同的区域

4、生成多边形网格

​	检测划分区域的轮廓并构造成简单多边形，再将轮廓分割成多个凸多边形

​	对所有多边形网格进行三角化，并且基于多边形中高低不平的地面部分插入顶点，构建三角形



拆分区域后会加速寻路

A星算法寻路时只要关心区域与区域之间的路径即可

因为凸多边形内的任意两点可以直达，凸多边形让寻路更简单





# 技术选型



## 寻路算法



2D平面 或者 有起伏的地面寻路：

1、2D寻路 + y轴射线碰撞获取位置坐标

2、在服务器已2D平面数据的方式保存和运算数据



2D RPG 游戏中的 寻路：多层级2D网格

增加一个中间层



3D ：体素寻路网格构建算法

RecastNavigation NavMesh



## 地图编辑器

1、可行走区域与障碍区域的构建（使用不同颜色的多边形）

​	2D类型：方格

​	3D类型：

​		方法1：多边形或者标记障碍物的flag设置障碍物 ，地表网格 + 障碍物网格生成三角寻路网格

​		方法2：RecastNavigation NavMesh 扫描、制作三角寻路网格

2、地形与物件逻辑

​	地形：一个或多个大的网格模型，基于高度图和元素分布图来确定场景中地形高低和植被范围

​	物件：元素形式的存在（有坐标、旋转角度、缩放大小）

3、游戏逻辑（关卡、触发、事件、怪物出生 等 业务逻辑的参数配置）





### 地形制作



#### 定制地形

美术人员：Maya 、3DMax



#### 2D地形：程序生成拼接地形（只有一个 DrawCall）

2D RPG 类型

游戏运行时，程序将地图数据加载进来后，由于每个方块地图都是一个矩形面片，因此每一块地图都是实时生成后拼接起来的

因为 **只使用了一个程序生成的网格和一个材质球 和 一个动态生成的贴图**

所以 **整个地图只有一个 DrawCall**



2D 游戏中，地图程序拼接都是通过生成顶点和三角来完成的

1个方块格子 = 2个三角形拼接



##### 合并为一个大网格 - 降低 DrawCall

地图方块上顶点的UV指向地图贴图中的某一块

地图贴图以图集的方式存储地图上不同类型的贴图

拼接前让贴图先自动拼接，拼接后记录每个部位的UV信息，拼接地图的时候使用

伪代码：

```
//生成地图
void Generate_map()
{
	//遍历每块矩形的方块位置
	for i to  width_count then
		for j to height_count then
			meshInfo = Generate_trangle_by_rectangle(i, j, _type, texture_info);
			//生成单个网格信息
			meshList.Add(meshInfo); //汇总
        end
	end
	
	//合并所有的mesh
	CombineMeshList(meshList);
}


void Generate_trangle_by_rectangle(int _x, int _y, int _type, texture_info _tex)
{
	//矩形的4个顶点
	point1 = vector2((_x - 0.5) * width, (_y + 0.5) * height);
	point2 = vector2((_x + 0.5) * width, (_y + 0.5) * height);
	point3 = vector2((_x + 0.5) * width, (_y - 0.5) * height);
	point4 = vector2((_x - 0.5) * width, (_y - 0.5) * height);
	
	//顶点增加后的索引位置
	point_index1 = add_point(point1);
	point_index2 = add_point(point2);
	point_index3 = add_point(point3);
	point_index4 = add_point(point4);
	
	//三角形生成的顶点
	trangle1 = [point1,point2,point3];
	trangle2 = [point3,point4,point1];
	
	//三角形顶点的索引信息
	trangle_index1 = [point_index1,point_index2,point_index3];
	trangle_index2 = [point_index3,point_index4,point_index1];
	
	//4个UV点位的信息
	point_uv1 = vector2(_tex.uv_x, _tex.uv_y);
	point_uv2 = vector2(_tex.uv_x + _tex.width, _tex.uv_y);
	point_uv3 = vector2(_tex.uv_x + _tex.width, _tex.uv_y + _tex.height);
	point_uv4 = vector2(_tex.uv_x, _tex.uv_y + _tex.height);
	
	//合并为一个渲染时候只有产生一个DrawCall
	Mesh mesh = new Mesh();
	mesh.trangles = [trangle1, trangle2];
	mesh.trangles_index = [trangle_index1, trangle_index2];
	mesh.uvs = [point_uv1, point_uv2, point_uv3, point_uv4];
	
	return mesh;
}

```



#### 3D地形：

针对可拆分的地图类型项目

1、制定模型规范：

规定了每块地形的大小尺寸后，每一个3D地形模型都要按照这个标准来定制（允许有空白）

2、同一个地图上的地形模型的纹理贴图合并到一张图集上制作

这样就可以在合并模型的时候合并材质球

并且合并后让多个3D小方块只需要一个DrawCall渲染就可以绘制所有地图

3、实例化场景地图时增加逻辑更好的适应模型拼合

城墙拐角的拼接的时候需要先判断前后左右是否有其他城墙

4、合并模型

UnityAPI ：Mesh.CombineMeshes 合并所有 模型

三角形面数的限制（2的16次方 - 1 = 65535）面



### 地图编辑和存储（JSON + Protobuff）

地图编辑器中的数据协议：

1、自定义格式的数据协议：

把每个变量转换成byte流形式存储起来可以最大化节省空间

缺点：二进制数据流格式对变化适应能力非常弱，每个版本的数据格式需要编写一个完整读取和存储的程序，每增加一个版本需要在原来数据解析的程序增加一个新的数据解析程序

2、**Protobuf（推荐）**：

也是二进制数据流格式，轻松应对数据格式升级和改变，数据小解析速度快升级方便

缺点：不能明文显示

3、JSON：

明文



**JSON + Protobuff**：

JSON作为编辑存储数据、发布打包将数据转换成 Protobuff协议加载和使用更高效 



### 地图加载和释放

#### 阻塞加载 + 按需异步加载

1、最关键的 部分使用阻塞的加载方式

地形、碰撞体、主要景观模型等

2、根据地图编辑器的数据进行异步流式的动态从近到远的加载

其他物件

缓解CPU某个瞬间的消耗

分块、分批加载



#### 地图九宫格（25宫格、49宫格的形式加载和释放）

将整个世界横切和竖切拆分到各个块中

每个块的内容都是独立的可以被独立加载或者独立卸载

角色移动到另一个地图块的时候周围九块地图发生的变化，这时候加载新的地图块，同时卸载被废弃的三块内容



#### 缓冲时间后逐步释放

加入缓冲时间 减少内存和 I/O 上的消耗

平滑过渡和加载整个场景









