各种各样的行为方式，状态机无法满足



# 行为树：控制行为（注重变化）

树形结构

让人更容易编写出复杂的AI行为

简化逻辑拼凑

“化繁为简”：通过一些简单的操作制作能够达到人类所语气的足够复杂的机器人行为方式的效果



# 行为树本质：树状节点

扩展节点逻辑的功能实现复杂的行为逻辑



1、每个节点可以选择某种类型的功能节点，也可以选择某个叶子节点

2、如果没有叶子节点，功能节点会以各种逻辑顺序选择是继续访问下面的子节点还是直接停止

3、结果返回给父节点

4、父节点得到子节点结果后继续允许相关逻辑



# 复合节点 - 决策节点



## 类型1：选择节点

从头到尾执行自己子节点，一个子节点返回为 true 则停止迭代返回为true，否则迭代执行到最后返回给父节点 false

随机性：可以增加 **随机权重选择节点**



## 类型2：顺序节点

从头到尾执行自己子节点，一个子节点返回为 false 则停止迭代返回为false，否则迭代执行到最后返回给父节点 true

随机性：可以增加 **随机权重选择节点**



## 类型3：并发节点

并发执行所有子节点

并发性

在协程或协程上使用，可以充分利用CPU提高性能

并发节点下可以放置多个Action子树，或者挂载多个条件节点



### 并发类型1：并行选择节点

执行完所有子节点后，如果有一个为 false，则向父节点返回 false，只有当所有子节点都返回true时，才向父节点返回 true



### 并发类型2：并行顺序节点

执行完所有子节点后，如果有一个为 true，则向父节点返回 true，只有当所有子节点都返回false时，才向父节点返回 false



### 并发类型3：并行混合节点

执行完所有子节点后，按照指定数量的节点返回true 或者 false 后 再决定返回结果



# 修饰节点 - 决策节点

对子节点返回的值进行额外修饰处理，再继续传递返回给父节点



## 类型1：反向修饰：!取反

结果反置返回



## 类型2：直到失败：while

指定次数内到达前一直返回 false，次数满足后 返回 true



## 类型3：总是失败

强制返回false



## 类型4：计数

只运行子几点n次，超过次数后不在运行



## 类型5：时间

指定时间内运行的子节点都是返回 true

超出时间后返回的一定是 false



## 类型6：空

什么都不做，单纯占位为后面功能预留



## 类型7：调试日志

输出节点位置和信息



# 条件节点

条件满足返回 true 否则 返回 false



## 类型：大于 小于 等于 与 或

用于和变量组合使用（血量判断、距离、状态、时间间隔）



# 行为节点（最丰富的节点库）

最后的叶子节点

完成具体的一次（或一小步）行为之后根据计算或者配置返回返回值

一次或分步执行很多次的行为

自定义角色行为的关键：设计了角色的具体行为

根据项目的需要从基础行为节点扩展

都必须向上层的父节点报告执行结果：成功或失败或正在硬性



## 类型1：行走到目标地点



## 类型2：追击目标



## 类型3：使用物品



## 类型4：撤退



## 类型5：攻击目标



....



# 决策树：制定决策（注重选择）

树形结构

树叶由节点构成

最后一定会执行到叶子节点，进而确定当次行为的动作

只有叶子节点才能决定如何行动

在决定后的行动中无法中途退出

必须等到当次行为执行完毕或者被打断才能进行下一次决策





1、行为树可以定制比决策树更复杂的AI逻辑

​	原因：单个节点的易扩展性，状态机中的每个状态的扩展难度相对比较大

2、行为树的难度比决策树高不了多少









