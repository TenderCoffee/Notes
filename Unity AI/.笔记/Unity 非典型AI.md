# 可演算AI

策略类游戏

卡牌手游自动战斗

​	

服务端计算好以数据（队列的形式存储）的形式代表整个过程下发给客户端，客户端再演示

客户端根据演算的数据展示人物表现



## 特点一：确定性

​	无法随机改变或者随时间变化而变化，同样的数据多次计算结果相同

​	优化：随机数种子 同个算法校验达到相同演算减少数据传输



## 特点二：时间轴演化游戏进程

​	卡牌对战算法

​	先由敏捷度最高的英雄进攻，等待英雄进攻完毕后，再由次高敏捷度的英雄进攻，依次进行下去，直到所有英雄进攻完毕再发起新一轮进攻。



进攻的基准：

不以时间轴 - 敏捷度：

​	进攻 = 回合 = 先对敏捷度排序，再 for循环，依次计算进攻详细内容

时间轴 - 冷却时间：

​	进攻 = 冷却时间先结束

​	进攻的时候，其他英雄等待

​	有序的剩余冷却时间队列：

​		把所有英雄加入一个队列排序得到谁的剩余冷却时间最短开始计算进攻细节，一直计算直到演算结束



更复杂的时间轴：

​	进攻的时候，其他英雄也有进攻操作，增加了进攻消耗时间排序插入以及死亡判定排序

​	既要在冷却时间结束时计算进攻，还要在选择进攻对象时计算该英雄是否已经判定死亡，最后在进攻完毕后，计算当前的时间并插入到排序队伍中，需要将每个关键时间点都计算出来并依次演算。

​	**必须定义“时间节点”：在整个过程的时间轴上，一个事件发生时所在的位置**

​	将时间节点作为计算标准把所有人物的下一个事件的时间节点都计算出来，每个时间节点都可能引起其他时间节点的变化，被打断后都需要重新计算，都要对可能产生变化的人物的时间节点重新计算，再次加入队列。



# 博弈式AI

目标是打败玩家赢得比赛

最大特点：搜索，通过搜索将所有下一步可能会发生的以及下几步可能发生的事情都记录在内存中，以此确定电脑如何进行下一步的动作，获得最大效益。

**改进搜索算法效率：最短路径算法解决搜索问题 + 搜索中引入枝剪和优化**

对结果估值： 0 - 100的浮点数 得到行动收益
