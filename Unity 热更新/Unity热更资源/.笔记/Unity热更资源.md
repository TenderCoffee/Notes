# AB（AssetBundle）资源

AB包 放到项目外 - 服务器



AB包支持 图片、预设体、文本、音频、字体、DLL文件 等等

**AB包不支持 C# 代码热更新**



# 版本检测原理

服务器版本号 和 客户端版本号



1、打包准备

划为ABName，生成AB包

每次打包时候要生成一个配置文件 assetslist.txt

1) 记录了打包的时间
2) 记录了所有打包资源的描述
   1) ab包名
   2) MD5信息
   3) 资源包大小
   4) 其他信息（level）- 如 资源是否常驻

2、更新检测原理

 1. 检测服务器上最新的 assetslist 的大版本号 和 本地的 assetslist 的大版本号，如果本地 小于 服务器，则开始第2步

 2. 逐一判断 当前版本的 AB包 的 MD5信息 和 本地版本对应的AB包的 MD5 信息做比较

    相同则不需要下载，不同则添加到下载列表

	1. 根据下载列表开启下载

​	

# 版本检测的目录

1、persistentDataPath 目录

​	允许开发者 读写

​	下载AB包后写入这个目录



2、SteamingAsset 目录

​	只能读，不能写，不加密的目录

​	假如游戏已经更新了一年，AB包已经产生了1个G的大小更新

​	则新玩家下载后，进游戏还需要网络下载1个G的更新才能进游戏

​	为了让新玩家直接跳过这个下载的流程，可以将 1G的更新AB包直接放到 SteamingAssets 文件夹下，然后打一个新的渠道包。

​	新玩家进入游戏后，WWW方式读取资源将这些已经在目录下的资源放到 persistentDataPath 目录（不需要联网下载），再解压出来，解压后再判断热更新



3、Resources 目录

​	只能读，不能写，加密的目录

​	存放不用热更新的资源



打包一个APK，修改后缀为 zip，解压后文件夹中SteamingAsset 目录可以直接取到其中的资源，Resources 目录下的解压后是加密的。



4、资源服务器

存放资源AB包

定位 资源服务器在网络的位置

	1. 开发环境可以使用IP环境
	1. 生产环境使用域名

使用IP服务器， 从IP服务器上获取资源服务器地址

上线后接入全国的 CDN 节点



# 检测和下载AB包的执行流程



1、项目启动，进入热更新检测模块

2、首先判断 persistentDataPath 是否存在

​	如果不存在

		1. 创建目录
		1. 创建 assetslist.txt 文件，版本号为0

3、从 SteamingAssets 目录复制文件

	1. ab包复制到 persistentDataPath 目录
	1. assetslist.txt 也一起复制到 persistentDataPath  目录下

4、下载检测 CheckResources

 	1. 从资源服务器上下载 assetslist.txt - 几KB大小
 	2. 从本地 persistentDataPath 读取本地的 assetslist.txt
 	3. 获取到 serverTime  和 localTime - 版本号
     	1. 当 timeSever > timelocal = 开启下一步
     	2. 如果不大于 则不需要热更新 = 进入登录Login

4. 开始逐一检测服务器的 AB包

   1. 如果本地的 assteslist 里 不包含这个AB的信息

      则需要加入下载列表

   2. 如果本地存在，但是 MD5值 不一样（文件可能被破坏掉）

      加入下载列表

 	5. 确定下载列表后
     	1. 得到总下载大小
     	2. 单个文件的下载大小

5、开启下载协程下载资源

 	1. 每个资源在服务器的下载地址是 IP+ab.name + ab.md5
 	2. 通过 www 下载
 	3. 通过 File.WriteAllBytes 写入到 persistentDataPath 对应的AB包文件，把服务器上的AB包成功写入到客户端的硬盘上
 	4. 更新本地的 assetslist.txt

6、下载完成后

 1. 资源处理

    	1. 常驻内存资源先读取并加载
        	1. Lua
        	2. Shader
        	3. 字体
        	4. 声音
    	2. 模块资源在模块开启之前由资源管理器负责加载

 2. 初始化游戏

    进入登录界面







# AB包的问题



## 依赖

假设有一个AB包1里有一个预设体，上面引用了一张图片

如果这张图片存在AB包2（AB包1 依赖于 AB包2 的资源）

假如只加载了AB包1，那么预设会丢图

假如先加载AB包1，在加载AB包2，那么预设体也还是丢图

必须先加载依赖包

先加载AB包2，再加载AB包1，才能够在预设上正常显示图片



旧做法：

资源管理器，在使用AB里的一个Asset的时候，要根据依赖文件找到依赖的所有的AB包，先行加载，再加载自己



新做法：

按照功能模块划分资源，公共资源独立

模块运行前先加载公共资源，再加载模块资源

功能关闭的时候清理对应的AB包

或者功能关闭的时候 延迟清理AB包（倒计时）



高级机制：结合业务

比如功能：10级之前使用非常频繁，10级之后20级之后使用频率不同

则 清理的时候加一个维度判断，如 等级



## 冗余



