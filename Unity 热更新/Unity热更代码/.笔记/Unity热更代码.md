[TOC]



# Unity为什么不能热更代码

C#的整个编译执行过程是先通过编译器将C#编译成IL（Intermediate Language），再由CLR（Common Language Runtime）将IL编译成平台相关的二进制机器码进行执行



## Mono 反射执行DLL文件（CIL程序集）只对Android热更生效

C#编译出来的.dll文件不是“老古董”的windows下的动态链接库，而是中间语言（CIL）的程序集（assemblly）。对unity来说这些CIL是通过mono虚拟机来运行的



在JIT（Just in time）模式下可以做到运行时将IL编译成机器码，此时如果C#利用反射动态加载程序集，则通过替换DLL文件即可完成C#热更

虽然Android是支持JIT的，但IOS并不支持。



**IOS不允许获取具有可执行权限的内存空间（禁止JIT编译），不能通过DLL文件直接更新代码**



**IOS仅支持AOT（Ahead of time）模式，且Mono在IOS平台上使用的是Full AOT模式，会在程序运行前就将IL编译成机器码。**

如果使用反射执行DLL文件，就会触发Mono的JIT编译器，而Full AOT模式又不允许JIT





# 程序运行的三种方式

- 静态编译（C/C++)
- 动态解释（原生的lua）
- 动态编译（可以简单理解为对某些热点代码进行编译，进而优化解释执行的过程）



# Android 和 IOS 都适用的热更新方案



## 如何实现两门语言互相调用

### 1、方式一：RPC

​	远程过程调用（就是说，A程序要调用一个b方法，然而这个b方法的实现在B程序内部，B程序还可能和A不在一个电脑上面，怎么调用？http可以调用/rpc也可以，让他像调用本地方法一样调用）

### 2、方式二：语言扩展API

​	大多数语言都提供了C语言的扩展，可以用C语言作为桥梁实现语言间相互调用



## 基于 Lua 的热更新解决方案

Lua 热更新原理：

​	利用相关插件(`xlua,tolua`)提供一个**Lua的运行环境（虚拟机）**，为Unity提供Lua编程的能力，让C#和Lua可以相互调用和访问。



优点：

  		1. Lua由C语言编写通用性强几乎在任何操作系统均可运行。
  		2. Lua作为轻量小巧的脚本语言，由Lua虚拟机解释执行，热更只需进行简单的文件替换，无需进行编译。
  	   开发经验浓厚，有很多成熟的项目和方案。



缺点：

 1. Unity原生使用C#，多使用一门Lua语言会增加学习和开发成本

 2. Lua是弱类型非面向对象的语言，面对较大的项目时将无法像传统OOP语言一样分层和模块化开发等，容易造成代码结构混乱和维护困难等问题。

 3. 需要利用插件在C#环境下提供Lua运行环境，并且还需要为Lua和C#之间提供数据的通信和相关转换，效率低下，远不如用原生C#进行开发。

    

### 热更方案1. toLua

基本原理：

​		**ToLua 框架主要是提供一个Lua的虚拟机， 通过静态绑定来实现C#与Lua之间的交互的。基于LuaInterface 使得lua脚本可以实例化 CLR 对象，访问属性，调用方法甚至使用lua函数来处理事件** 



LuaInterface 是一个实现lua和微软.Net平台的 CLR 混合编程的开源库



C#调用Lua原理：

​		数据通信和xLua类似，获取内存中数据引用后也需要进行转换，转换方式和XLua有所区别，ToLua实现了**LuaInterface建立了Lua与C#之间的映射**，使用C#的类型建立了lua的基础数据模型，然后在这个基础上建立了运算规则。



Lua调用C#原理：

​		与其它框架不同的正是其静态绑定的特点，在Lua调用C#时，其提供了一个 **C#文件（CustomSettings.cs) 显示注册C#组件**，启动虚拟机时会利用LuaInterface将注册了的C#组件映射到Lua上，包括基础类型的转换、自定义类型到table的转换、函数的转换，最终均注册到Lua的大G表(global table)中实现Lua调用C#。



Unity热更代码_toLua.md 文件



### 热更方案2. xLua插件：基于 IL代码注入热更

基本原理：

​		**XLua框架的基础是实现了运行在C#环境上的Lua虚拟机使得Lua可以和C#实现相互调用和访问。利用 IL 注入，实现用Lua函数替换C#原函数。**



C#调用Lua原理：

​		Lua由C语言实现自带C/C++的通信机制接口，C#可以借助C与Lua进行数据通信，在内存上进行数据交换。从内存中直接获取到的数据引用还需进一步转换成C#的相关类型才能使用，xLua在castersMap中定义了lua数据类型到C#类型的转换函数，转换后即可实现C#调用Lua。



Lua调用C#原理：

​		数据通信原理同上，简单基本值类型通过C API可轻松实现传递，但复杂的对象则需要通过Lua的userdata表和C#对象的映射实现，每个C#对象均在Lua中对应一个userdata表，然后lua会为userdata设置元表，元表中表示的是实际对象的类型信息，在C#对象传递到Lua后还需告知诸如对象的类型，静态/成员方法、属性等信息注册到Lua后，Lua才能正确的调用C#相关对象函数等。

元表在此可以理解为是C#中的Type类，所有C#对象均有一个类型对象指针，类型对象中存有方法表，静态字段等信息，userdata表只存有类中具体的成员，还需要元表充当类型对象才能正确的和C#对象映射成功。



**热补丁原理：**

​	利用IL注入，实现用Lua函数替换C#原函数。实现的基本原理为：根据Lua脚本热补丁命令生成匹配文件（DelegatesGensBridge.cs）里面存有Lua提供的热补丁函数引用，再根据特性的标注[Hotfix]等，定位到目标函数上创建静态变量DelegateBridge。当Lua为其提供了热补丁函数，则此变量不为空否则为空，再利用此变量进行条件判断，实现不为空时根据匹配文件中Lua函数引用去执行，不继续向下执行原C#函数。若为空则执行原C#函数逻辑。



Unity热更代码_xLua.md 文件



### **两种 Lua 解决方案的比较**

1. ToLua提供的热更新不完善，C#项目转Lua做热更新建议用XLua的热补丁。
2. ToLua采用的是静态绑定在文件中显式注册的方式减少了反射次数，XLua则是提供了一系列特性也一定程度上减少可反射次数。
3. **ToLua对泛型的支持糟糕，会有大量的拆装箱过程，效率较低**。XLua完善了对泛型的支持，减少了拆装箱的次数。



## 基于 C# 的热更新解决方案

基本原理：

​		**本质上用编译好的新DLL替换需要更新的旧DL**L。只能进行代码热更新，还需配合AB包的资源热更新一起使用



优点：
		和Unity开发均使用C#，开发语言统一，编码更容易。

​		使用纯C#开发无需另创虚拟机等环境，**效率高，性能远高于Lua**



缺点：
    1. 方案均有各自的局限性，**直接反射方式不仅损耗性能，在不支持JIT的系统（IOS）上无法使用**。
  2. ILRuntime解决了JIT的问题但不够成熟，使用问题较多，需要较高的动手解决问题能力。




### **两种 C# 解决方案的比较**

1. DLL反射热更新: 使用编译后的DLL文件进行替换，利用反射方式把所需C#组件绑定到相应的对象上使用。
2. ILRuntime：**本质还是DLL的替换**，但实现了一个ILR（IL运行时）使其能够在不支持JIT的硬件环境（IOS）下实现代码热更新。



### 热更方案1. ILRuntime



ILRuntime借助 **Mono.Cecil 库来读取 DLL 的 PE信息** ，以及当中类型的所有信息，最终得到方法的IL汇编码，然后通过内置的IL解译执行虚拟机来执行DLL中的代码来实现热更新功能。

ILRuntime源码内部有一个**很大的switch/case结构**，就是**针对基本上每一条IL指令码进行解释**，同时维护一个**栈帧（Stackframe）**用于模拟cpu的函数调用的基本操作进行辅助解释。

ILRuntime中解释热更dll中的自定义类实例，在框架层这边都是对应的同一个warper，即 **ILTypeInstance** 。

ILTypeInstance会知道最终被调用方法的 il指令内容，如果调用，则就是switch逐句去解析这个方法的IL代码。

这样一来就没有什么执行权限的问题，简单理解为读取一个普通文件，然后解析文件内容。

如果是反射处理这种情形，那就是真实的构建出一个新的类型，然后调用新类型的方法，这倒是会涉及到内存权限题。



基于 ILRuntime 的热更代码保护：

1. 对 ILRuntime 来说，DLL 就是普通的 二进制资源
2. 所有对于资源的加密均可用于热更 DLL
3. 常见的保护方式
   1. 将热更DLL更名为 .bytes ，加密后打入 AssetBundle（加密 https://zhuanlan.zhihu.com/p/356693738）
   2. 仅对文件头进行加密可降低加密所带来的开销
   3. 对 AssetBundle 进行加密处理
4. 对主工程进行常规加固（可利用 Unity 自带加固方案），因为密钥都是放在主工程里



ILRuntime 的实现细节

![](images\ILRuntime 的实现细节.png)



缺点：

1. 有 Mono虚拟机 环境，虚拟机解释，再跟Unity原生交互，会产生开销
2. ILRuntime 本身有自己的虚拟机，ILRuntime 的数据类型 和 C# 的数据类型不统一，要适配 ILRuntime 的泛型，代理，继承





### 热更新方案2.HybridCLR - 未来趋势



混合的 CLR = **AOT + Interpreter（直译器） 混合运行方式**，不需要虚拟机



在 IL 和 IL2CPP 之间 插入 HybridCLR，编译了要热更的代码

1. 扩充了 IL2CPP 的代码，使它由纯AOT runtime 变为 AOT+Interpreter 混合 Runtime，进而原生动态支持加载 Assembly，使得**基于 IL2CPP backend 打包的游戏**不仅能在 Android 平台，也能在 IOS，Consoles 等限制了 JIT 的平台上高效的以 AOT+Interpreter 混合模式执行，**从底层彻底支持了热更新**。
2. HybridCLR 可以对 AOT dll 任意增删改，会智能的让变化或者新增的类以 Interpreter  模式运行，但从未改动的类和函数以 AOT 的方式运行，让热更新的游戏逻辑的运行性能基本达到原生的 AOT 的水平。



Unity热更代码_HybridCLR.md 文件



