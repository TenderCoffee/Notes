# 线性表（Linear List） 和 非线性表

线性表: 数据排成像一条线一样的结构.每个线性表上的数据最多只有前和后两个方向

​	数组,链表,队列,栈

![](.\images\线性表.webp)



非线性表: 数据之间并不是简单的前后关系

​	二叉树,堆,图

![](.\images\非线性表.webp)



# 数组（Array）- 基本的数据结构

数组的下标是一种offset的概念, 而不是第几个的意思. 方便与机器对于地址的解析, 符合计算机的寻址方式.

**数组是一种线性表数据结构。数组在物理上是一种顺序的存储结构。它用一组连续的内存空间，来存储一组具有相同类型的数据**



1、线性表结构

2、连续的内存空间 和 相同类型的数据：拥有“杀手锏”特性 - **随机访问**



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////			数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，

//////////			但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。

//////////			在平时的业务开发中，我们可以直接使用编程语言提供的容器类，**但是，如果是特别底层的开发，直接使用数组可能会更合适**

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



## 随机访问 - 随机选择下标，进行数据访问

随机访问的缺点：

​	数组很多操作会低效：数组 **为了保持内存数据的连续性**，数组删除、插入数据 需要做大量数据搬移



### 一维数组 内存寻址：实现根据下标随机访问数组元素 - base_address + 偏移量操作计算

计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。

当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：

 <u>**a[i]_address = base_address + i * data_type_size**</u>

base_address ：内存块的首地址

data_type_size ：数组中每个元素的大小（int 类型 = data_type_size 为 4个字节）



举例：

```
//Int长度是4个字节，所以分配的内存长度是10×4=40字节，此处内存分配从1000-1039共40个字节长度。
//这里 内存块的首地址为 base_address = 1000
int[] a = new int[10]
```

![](.\images\数组_实现根据下标随机访问数组元素.webp)





### 二维数组 内存寻址

对于 m * n 的数组，a [ i ][ j ] (i < m,j < n)的地址为： address = base_address + ( i * n + j) * type_size



### **数组跟链表的区别**

​	数组只要计算出 base_address（内存块的首地址），数组其他元素基于偏移量很快就可以计算出来，所以才支持随机访问，这样直接根据下标随机访问的时间复杂度是O(1)



### 注意：访问 ≠ 查找 ！



#### 访问时间复杂度 - O(1)



#### 查找时间复杂度 - 取决于用的算法（二分查找 - O(logn)）

想要查找数组里的某个值，算法复杂度取决于用的什么算法

二分查找：时间复杂度 O(logn)



### 低效 插入 和 删除



#### 插入操作 - O(n)

插入的位置不同,会导致针对同一段代码的时间复杂度有量级的差距

1、我们插入的位置位于数组的最后一位：

不需要移动任何元素,最好时间复杂度为O(1).

2、我们插入的位置位于数组的第一位：

需要移动n个元素,最坏时间复杂度为O(n)

3、平均时间复杂度：

概率：因为插入到任一位置的可能性都是一样的，因为有 n个位置，所以插入到每一个位置的概率都是1/n

插入到数组的第一个位置需要移动 n个元素. 插入到数组的第二个位置需要移动 n-1 个元素,...,插入到数组中的最后一个位置,需要移动1个元素. 

所以：(1+ 2+  ... + n-2 + n-1 + n)/n = (n+1)/2 = O(n) 

**数组插入操作的平均时间复杂度为O(n).**



#### 数组插入的时候如何避免大规模的数据搬移 - 直接交换数据值 时间复杂度 - O(1)

使用场景：某个元素出于某种占位的目的，就是要排在K位

使用前提：数组只是一个容器作为存储功能数组里面的数据元素是无序的

使用方式：当需要将一个数据插入到数组中的第 k 个位置的时候，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位



假设：数组 a[10]中存储了如下 5 个元素：a，b，c，d，e

需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2]赋值为 x 即可。

最后，数组中的元素如下： a，b，x，d，e，c

![](.\images\数组插入的时候如何避免大规模的数据搬移_直接交换数据值.webp)



#### 删除操作 - O(n)

要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。



如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；

如果删除开头的数据，则最坏情况时间复杂度为 O(n)；

平均情况时间复杂度也为 O(n)：概率是每个元素被删除的概率是1/n，平均操作次数 （n-1 + n-2 + n-3 + ... + 1 + 0）* 1/n = (n-1)/2。 去掉系数->复杂度O（n）



#### 删除不一定非要追求数组中数据的连续性 - 删除操作集中在一起执行

数组 a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素

![](.\images\数组删除操作集中在一起执行.webp)

因为删除多少个元素 = 其他数据被搬移多少次

所以先记录下已经删除的数据。

每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。

当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移



#### 假删除：JVM 标记清除垃圾回收算法的核心思想

大多数主流虚拟机（JVM）采用可达性分析算法来判断对象是否存活

JVM 垃圾回收算法：

1、复制算法.

2、标记清除算法

​	**简单思想：**

​	在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。

​	只有当标记工作完成后，清理工作才会开始。

​	缺点：

 	1. 效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效 
 	2. 空间问题。会产生不连续的内存空间碎片。

3、标记整理算法

​	**简单思想：**

​	数组中删除数据时,并不真正的删除,而是标记一下,先不进行数据的搬移工作。

​	**等数组空间不够用时,我们再执行删除操作.进行数据的搬移工作.** 

​	这样可以减少因为删除操作导致的数据搬移. 



缺点：

​	这种垃圾回收算法 容易产生内存碎片,导致出现虽然内存空间充足,但是无法放置大对象的诡异现象.



## 访问越界 - C语言可能死循环

```

int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    //当 i=3 时，数组 a[3]访问越界
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

注意：C语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。

因为对于不同的编译器，在内存分配时，会按照内存地址递增或递减的方式进行分配。

**函数调用的栈桢结构细节：函数体内的局部变量存在栈上，且是连续压栈**

如果是编译器在内存分配的时候，内存地址递减的方式

在这段程序中

变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。

根据我们前面讲的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址

那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。





### 访问数组的本质：访问一段连续内存

只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误

java,python 会进行越界检查报错抛异常，在c语言中，数组出现越界时，一样可以访问，只是访问的不是对的数据

计算机病毒：利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统



Java 越界检查：ArrayIndexOutOfBoundsException 属于 运行期错误，而不属于编译期错误



# 容器 - 对数组的封装

List 等语言中的数据类型，自动实现一些功能去实现对数组的操作

Java 中的 ArrayList、C++ STL 中的 vector



## Java - ArrayList

最大的优势：

1、将很多数组操作的细节封装起来 - 插入、删除数据时需要搬移其他数据

2、支持动态扩容（自动扩容为 1.5 倍）

​	数组：因为需要分配连续内存空间，所以需要预先指定大小

​	ArrayList：数据存储不够用空间的时候，将原来的数据复制过去，然后再将新的数据插入



 缺点：

​	扩容操作涉及内存申请和数据搬移，是比较耗时的

​	如果事先能确定需要存储的数据大小，**最好在创建 ArrayList 的时候事先指定数据大小**

​	先指定数据大小可以省掉很多次内存申请和数据搬移操作



# 对数组的选择使用

1、Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 自动装箱、自动拆箱 则有一定的性能消耗

​	**所以如果特别关注性能，或者希望使用基本类型，就可以选用数组**

2、如果**数据大小事先已知，并且对数据的操作非常简单**，用不到 ArrayList 提供的大部分方法，也可以直接使用数组

3、当要表示**多维数组**时，用数组往往会更加直观。比如

```
 Object[][] array
```

​		而用容器的话则需要这样定义：

```
ArrayList<ArrayList<object>> array -- 不直观
```



我总结一下，**对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能**。

但如果你是**做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选**。



# 为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始



## 1、内存地址公式减少一次CPU的减法指令

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”

如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置

所以计算 a[k]的 **内存地址** 只需要用这个公式

a[k]_address = base_address + k * type_size

**如果 数组从 1 开始计数，会多一次减法运算，对于CPU多一次减法指令** - 人向机器妥协

a[k]_address = base_address + **(k-1)***type_size



## 2、历史原因

C 语言设计者用 0 开始计数数组下标

