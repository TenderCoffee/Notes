# LRU 缓存淘汰算法



## 缓存

硬件中的缓存: CPU缓存，而cpu缓存又可以分为寄存器，一级缓存，二级缓存，三级缓存。

软件中的缓存: 数据库缓存，数据库本身产品就自带缓存。

redis也可以作为数据库缓存. 浏览器缓存，就是我们常说的Cookie,本质上就是一个文件



缓存实际上利用了**空间换时间**的设计思想：

如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。

但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了



## OS虚拟存储器

每个进程只被分配几个内存块，当进程的内存块被占完了之后。从硬盘上又重新读取了一个内存块的数据量，这时候需要判断哪个内存块的内容被换出去比较合适

置换算法的缺页率上升 会导致 “抖动”：

​	置换算法采取的不好，就会导致缺页率上升，进程频繁的发生缺页中断，OS就会频繁的在内存和外存之间替换页面，影响了进程的执行效率

LRU 置换算法的缺页率相对比较低



## 缓存策略

买了很多本技术书，但有一天你发现，这些书太多了，太占书房空间了，你要做个大扫除，扔掉一些书籍



### 先进先出策略 FIFO（First In，First Out）

做法1：先看放在上面的书，把看完的放到另一堆里(双堆栈结构，像浏览器前进后退一样)



### 最少使用策略 LFU（Least Frequently Used）

做法2：不常用的书。这么多书也不一定全都是好书，读完鉴别过了之后。。。丢了吧



### 最近最少使用策略 LRU（Least Recently Used）

做法3：最近不常用的书。把好书坏书筛选一遍后，剩下的好书有的看起来对现在的我来说用处没那么大，那就先放一边，以后再翻阅。



# 链表



## 数组与链表 - 底层的存储结构的不同

​	数组需要一块 **连续的内存空间** 来存储，对内存的要求比较高

​		内存没有连续、足够大的存储空间时会申请数组失败

​	链表 **不需要一块连续的内存空间**，它通过 **“指针”** 将一组零散的内存块串联起来使用

​		允许不连续的存储空间



数组与链表：非常基础、常用的数据结构，其它复杂的数据结构，其实都是在数组和链表的基础上形成的



## 链表 相比较数组而言的缺点 - 方便但内存开销大近一倍

链表虽然方便。但是内存开销比数组大了将近一倍。

假设存储100个整数，

数组400个字节（100 * 4）的存储空间足够了。

链表需要800个字节的存储空间，因为链表中的每个节点不止要存储数据，**还要存储地址（4个字节）**，内存的利用率就比数组低太多了。 

![](.\images\数组和链表的内存分布.webp)



**所以，内存容量 是关键**

如果内存容量本身就很小，要存储的数据也比较多，选择数组来存储数据更好。

如果内存空间充足，那我们在存储数据的时候到底选择链表还是数组。这个就视具体的业务场景而定了



链表 通过 指针 将一组零散的内存块串联在一起

内存块：链表的 “结点”



## 单链表

后继指针 next：记录下个结点地址的指针

单链表中的每一个结点都必须具备两个功能：

​	1、存储数据，

​	2、记录下一个结点的地址

头结点：记录链表的基地址，有了基地址就可以遍历得到整条链表

尾结点：指针指向空地址 NULL，表示是链表上的最后一个结点，指向 NULL 的目的是防止尾节点的 后继指针next 成为一个野指针，导致遍历链表根本停不下来，或者出现一堆本不属于该链表的垃圾数据等

![](.\images\单链表.webp)



### 数据的查找 - 不支持随机访问 只能顺序访问 - O(n)

​	链表随机访问的性能没有数组好

​	单链表在执行插入和删除操作之前 需要找到要插入和删除元素的位置，这个查找过程是O(n).

​	因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址

​	**需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点**





### 数据的插入 和 数据的删除 - O(1)

​	在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的

​	链表的删除： 该节点的左节点的next 指向该节点的右节点，删掉该节点。 

![](.\images\链表的插入和删除操作.webp)



## 双向链表 - 常用

支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点

![](.\images\双向链表.webp)

缺点：占用更多存储空间，需要额外的两个空间来存储后继结点和前驱结点的地址

优点：支持双向遍历，双向链表的删除、插入比单链表更高效



<u>**对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；**</u>

<u>**而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗**</u>



### 数据的查找 - O(1)

解决的问题：可以支持 O(1) 时间复杂度的情况下 **找到前驱结点**

找到链表中某个结点的前驱结点：

单链表的平均时间复杂度为O(n)，因为需要从头节点开始找。 

双向链表的时间复杂度为O(1)，因为这个结点中的prev前驱结点指针域存放的是前驱结点的地址，通过这个地址就找到了该结点的前驱结点，所以时间复杂度O(1)



### 数据的插入 和 数据的删除

双向链表 **在某些情况下** 的插入、删除等操作都要比单链表（ O(1) ）简单、高效



#### 从双向链表中删除一个数据

**1、删除结点中“值等于某个给定值”的结点 - O(n)**

​	先定位到要删除的元素，然后再执行删除操作。 

​	定位到要删除的元素的平均时间复杂度为O(n) - 从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点 - <u>**遍历查找的时间是主要的耗时点**</u>

​	执行删除操作的时间复杂度是O(1).



​	时间复杂度加法法则：总复杂度 = 量级最大的代码的复杂度

​	所以 删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)



**2、删除给定指针指向的结点 - O(1)**

​	不用再去遍历找到被删除元素。直接删除这个指针指向的元素即可。

​	

#### 双向链表中的某个指定结点前面插入一个结点 - O(1)

​	单向链表需要 O(n) 的时间复杂度

​	双向链表需要 O(1)



#### 按值查询的效率 更高

对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。

可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据



### Java LinkedHashMap 的实现原理

使用了 双向链表 数据结构

**用空间换时间**





## 循环链表 - 环形 首尾相连

单链表最后一个节点里面存储下一个节点的内存地址为空

循环链表最后一个节点里面存储下一个节点的内存地址为 **链表头节点的内存地址**

![](.\images\循环链表.webp)



### 优点

从链尾到链头比较方便

处理的数据有环形结构特点的时候适用 - 约瑟夫问题



**阿橋问题**（有时也称为**约瑟夫斯置换**），类似问题又称为**约瑟夫环**。

人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，处刑下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。

问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。



循环链表是无须增加存储量，仅对表的链接方式稍作改变，即可使得表处理更加方便灵活。

① 循环链表中没有NULL指针。涉及遍历操作时，其终止条件就不再是像非循环链表那样判别p或p-＞next是否为空，而是判别它们是否等于某一指定指针，如头指针或尾指针等。 

② 在单链表中，从一已知结点出发，只能访问到该结点及其后续结点，无法找到该结点之前的其它结点。而**在单循环链表中，从任一结点出发都可访问到表中所有结点**，这一优点使某些运算在单循环链表上易于实现。这样他就可以更高效的实现算法， 循环链表，其结构特点链表中最后一个结点的指针域不再是结束标记，而是指向整个链表的第一个结点，从而使链表形成一个环。

和单链表相同，循环链表 也有 带头结点结构 和 不带头结点结构 两种，带头结点的循环单链表实现插入和删除操作较为方便。这样就可以更有效率





## 双向循环链表



![](.\images\双向循环链表.webp)



# 链表 VS 数组 

数组和链表是两种截然不同的内存组织方式

插入、删除、随机访问操作的时间复杂度

![](.\images\链表 VS 数组.webp)



注意：

不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据

链表插入、删除的方式不同具体的时间复杂度也不同，如果是在指定某个值之前或者之后插入，无论是单链表、循环链表、双向链表时间复杂度都不是O(1)



## CPU缓存存在的意义

比内存访问速度更快的机制。为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。

CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。

而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是**读取一个数据块并保存到CPU缓存中**，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。



CPU 缓存对数组的友好：

对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存，这样 **执行速度会快于存储空间不连续的链表存储**。



CPU 缓存行cache line，一般64位 CPU 每次会读取64字节数据到缓存



## 数组

简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。

缺点：数组由于占用连续空间，所以分配空间必须预先指定且固定，扩容时候只能数据拷贝（非常费时），同时容易OOM - 内存不足（out of memory）

优点：数组更适合对内存的使用非常苛刻



## 链表

链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读

优点：链表本身没有大小的限制，天然地支持动态扩容

缺点：

​	1、链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍

​	2、对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片（Java 语言会导致频繁的 GC）





# 用链表来实现 LRU 缓存淘汰策略

使用定长链表来保存所有缓存的值，并且最老的值放在链表最后面

当访问的值在链表中时：

​	将找到链表中值将其删除，并重新在链表头添加该值（保证链表中 数值的顺序是从新到旧） 

当访问的值不在链表中时：

​	当链表已满：删除链表最后一个值，将要添加的值放在链表头 

​	当链表未满：直接在链表头添加



缓存访问的时间复杂度：因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)



优化：引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)



# 判断一个字符串是否是回文字符串

回文字符串：是一个正读和反读都一样的字符串，字符串由数字和小写字母组成，比如“level”或者“abcdcba”等等就是回文串

即：关于中心左右对称的字符串



快慢指针：设定两个指针，其中快的指针的移动速度是慢的指针的移动速度的两倍

快慢指针方法主要用来解决两类问题：

​	1、判断一个链表是否为循环链表

​	2、寻找一个有序链表的中位数”



1 快慢指针定位中间节点（这里要区分奇偶情况） 

​	1.1 奇数情况，中点位置不需要矫正 

​	1.2 偶数情况，使用偶数定位中点策略，要确定是返回上中位数或下中位数 

​			1.2.1 如果是返回上中位数，后半部分串头取next 

​			1.2.2 如果是返回下中位数，后半部分串头既是当前节点位置，但前半部分串尾要删除掉当前节点 

2 从中间节点对后半部分逆序，或者将前半部分逆序 

3 一次循环比较，判断是否为回文 

4 恢复现场

时间复杂度O(n), 空间复杂度O(1)



# 单链表 反转



## 方法一：头结点插入法

1、创建一个带头结点的链表 resultList

2、定义一个循环链表变量p，p的初始值为待反转的链表

3、遍历待反转的链表，遍历条件为 p!=null

​	3.1 定义一个临时链表变量 tempList 保存 p->next 的值（因为 p->next值会改变），用于下一次循环

​	3.2 把 p 当前指向的首结点和 resultList链表的头结点之后的节点拼接起来

​	3.3 把上一个步骤中拼接的节点再拼接到 resultList 的头结点后

​	3.4 p 重新赋值为第一步骤中保存的 tempList 的值

4、返回 resultList->next 即 反转后的链表



# 写链表代码技巧



## 技巧一：理解指针或者引用的含义

指针 = 引用：都是存储所指对象的内存地址

指针存放的是变量的内存地址

p->next=q	意思是 	p 结点中的 next 指针存储了 q 结点的内存地址

p->next=p->next->next		意思是		p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址



## 技巧二：警惕指针丢失和内存泄漏

在堆上分配的内存，如果不再使用了，就应该及时释放，以便后面其他地方可以重用。

而在 C 语言中，内存管理器不会自动回收不再使用的内存。如果忘了释放不再使用的内存，这些内存就不能被重用了，这就造成了内存泄漏。 

也许对一般的应用软件来说，这个问题似乎不是那么突出与严重。一两处内存泄漏通常并不致于让程序崩溃，也不会带来逻辑上的错误，而且在进程退出时，系统会自动释放所有与该进程相关的内存（共享内存除外），所以内存泄漏的后果相对来说还是比较温和的。

但是，量变会导致质变，**一旦内存泄漏过多以致耗尽内存，后续内存分配将会失败，程序就可能因此而崩溃**



希望在结点 a 和相邻的结点 b 之间插入结点 x，假设当前指针 p 指向结点 a

![](.\images\链表_指针丢失.webp)



```

p->next = x;  // 将p的next指针指向x结点；
x->next = p->next;  // 将x的结点的next指针指向b结点；
```









