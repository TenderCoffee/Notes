# 模型导入处理

1、模型有法线 才能在场景中看到面

2、制作模型的时候，位置要在 0 点



## 导入的模型大小

Unity 默认的立方体，长宽是1厘米

Maya 默认的立方体，长度也是1厘米

但是 Maya 的模型导入到 Unity 后有缩放系数 Scale Factor：缩放系数

缩放系数 = 1 = 0.01 的缩放 = 缩小100倍

因此 Maya 的模型导入后 需要手动修改缩放系数 = 100



3ds Max 默认的单位是1米 -  不需要缩放



## 没有动画的模型

模型没有动画，直接取消Animation 的 Import Animation



## 给模型生成光照贴图

勾选 Generate Lightmap



# 光照



Shader：

1、Standard 用于 实时光的情况下

2、Unlit/Transparent Cutout 自发光



# 路径



## SteamingAssets - 只读 不可写

作用：游戏中存放资源AB包、数据库文件

游戏运行后，如果发现需要更新，可以将这个文件夹下的文件拷贝出来，放到其他目录再进行读写



# 灯光组 - 光源

场景制作完成后需要给场景加灯光，光源用于场景烘焙

一般场景有一个平行光 + 若干点光源

场景烘焙后 就可以将灯光组禁用或删除



灯光烘焙

Light 组件：Baking - Baked





# 判断前后左右 - 点乘叉乘

![](.\images\点乘 和 叉乘.png)



# HUD

头顶血条和伤害数字



## 大量 HUD 刷新出现卡顿的原因 - 占据很高的 CPU 耗时

传统 HUD 渲染：使用支持图文混排的文本控件，再将这些 UI 组合到一个面板中，通过刷新面板中的内容实现 HUD 的更新

1、控件的刷新 会 导致面板的 重绘制

2、SetActive 有一定的开销对性能产生影响

3、HUD 的频繁创建和释放会导致 垃圾回收频繁（GC）

4、HUD 使用对象池，大量伤害数字的激活与释放也会有很大的开销



高 CPU 占用：

UGUI  的 Canvas.SendWillRenderCanvased

NGUI 的 UIPanel.LateUpdate 



## 文字和图片的显示


文字：

​	CPU 加载字库文件（.ttf），在内存中生成对应文字的 **位图数据**，再用文字的位图数据更新到 GPU 支持的纹理中，并记录下该文字**在纹理中的坐标与 UV 信息**，进而构造这个字符的三角形数据，最后将这些三角形提交到 GPU 进行渲染



 文字的位图数据 => GPU 纹理 => 纹理中的坐标和 UV 信息 => 字符的三角形构造 => 提交三角形到 GPU渲染



Unity  的 font：

​	在首次请求文字的纹理缓存时，会生成一个 256x256 大小的贴图，当这个贴图装不下新的文字时，会扩大这个贴图的大小，最大可以达到 1024x1024，同时通知上层 “贴图变化”（TextureRebuildCallback）。

​	**如果当前贴图已经满了，又有新的文字请求时， font 同样会通知 上层贴图变化，这样就会导致所有的文字重新绘制。**



**文字和图片其实是纹理贴图，都是通过四边形（两个三角形）来渲染，对于 GPU 来说没有区别**



## 图文混排 - 解释器解析文本得到图元列表再更新到 Mesh 中



1、需要先使用 bool 变量 区分是文字还是图片

2、字符，char表示

3、图片id，int 表示（不能用 string 因为 string 开销较大）

4、纹理id 或 名字

5、UV 信息

6、颜色信息

7、相对坐标（混排的关键）



### 表示颜色

1、明码表示：2#RRRGGGBBB

[2#255000000] = 红色

2、十六进制：rrggbb

[00ff00] = 绿色

3、带透明度的明码：1#AAARRRGGGBBB

[1#128255000000] = 0.5 透明度的红色



### 表示图片

4#iconID,w,h

[4#120,50,50] = ID为120的图元显示大小为50x50的像素

5#iconname

[5#icon_01]：图元名字是 icon_01 显示原始大小



### 表情动画

6#ani_id;w;h

[6#1;40;40] = 动画ID为1的动画显示大小为 40x40 像素

[6#1] = 动画ID 为1 的动画 显示大小取表情自身的大小



有个 XML 的配置文件配置动画信息



### 表示超链接

7#链接字符;自定义字符串 = 默认链接，无下划线显示

7#链接字符;u;自定义字符串 = 有下划线

7#链接字符;f;自定义字符串 = 有下划线且闪烁提示



### 表示占位符

控制文本空格的大小

不需要被渲染，只是在文本排版时空出一个指定大小的位置而已

8#www-hhh

[8#40-40] = 40x40大小的不可见的空格



### 表示其他控制符

[ = [[ 表示

] = ]] 表示

\ 有效的 \

\n 手动画按行



## 描边、阴影 和 渐变效果的实现



### 描边的三种实现方案

1、在生成文字贴图之后，将位置用边缘扫描算法直接在原位图上勾边，再写入到字体纹理

会与普通文字采用同个材质，也不会有额外的三角形

但是因为 Unity 的 font 无法自己控制位图的生成，所以方案无法实现

2、使用 Shader 效果，在 Shader 中用算法描述出边缘

Sobel、Laplacian、Canny filter

不会产生额外的三角形，但是因为需要区分 Shader ，会打断 HUD 的合批渲染

**3、NGUI 的做法**

分别在文字的左上方、左下方、右上方、右下方 指定偏移量，指定阴影色，反复渲染四次，产生一个向外模糊的阴影

最后再叠加正常的文字，形成一个扩散性的描边效果

实现简单也不需要区分Shader，不会打断 HUD 的合批渲染

缺点：会增加三角形数量



### 阴影效果

在原位置向右下偏移一到两个元素



可能出现的问题：

如果文字是基于3D摄像机透视变换的，阴影的位移和描边在远处透视变换之后，位移量会变得很小，导致描边和位移效果不是很明显

解决：

先将摄像机变换到合适的分辨率，或者在 Shader 中自己控制顶点变换生成屏幕坐标，或者完全使用 2D 的方式，不做 3D 变换



### 渐变效果

文字是由一个四边形绘制而成，有四个顶点，在每个顶点上设置不同的颜色，再利用 GPU 的自动插值生成混合颜色

因为不会产生额外的 Shader，所以不会打断合批渲染



## GC

HUD 的 GC + Mesh 的GC + 控制字符串解析的GC

在 GameObject 上挂接 UI 做 HUD 渲染太重度，创建和释放都有不小的开销



**消除GC：无UI 的方式实现 HUD**

**自己解析字符串，直接生成渲染对象（Mesh），并挂接到摄像机上来渲染**

**再配合对象池，实现伤害数字的显示与隐藏无任何 GC**



```c#
class HUDVertex
{
    HUDVeretex m_pNext;		//下一个节点
    static HUDVertex s_InvalidList;		//这个类的全局缓冲对象
    public static HUDVertex QueryVertex();	//
    public static void ReleaseVertex(HUDVertex p);
}
```



## 高效渲染大量的头顶信息与伤害数字

HUD 的开销主要由 GameObject 和 Mesh 的刷新，以及 GC 导致

1、取消 GameObject 不使用 UI 的方式显示 HUD，自己解析 HUD 内容，消除 GameObject 的创建、销毁、显示与隐藏的开销

2、全程使用对象池，将字符串解析过程中生成的数据全部使用对象池，减少 GC，使用自定义的 List 或者 链表消除 GC，尽可能使用 ID，减少字符串的拷贝与内存的开销

3、将 HUD 分离成相对运动和相对静止的两个列表，减少逻辑更新与 Mesh 频率

4、使用 unsafe 修改 List 的长度，解决 Mesh 的数据更新产生的 GC



动静分离与转换规则：

1、所有对象首次添加时，默认是运动的（也可以是静止的）

2、对象移动，标记记录一下移动时间，并通知 所属 Mesh 刷新

3、每隔一定时间（2s）扫描所有对象

​		如果对象在静止批，对象有移动，就从静止批移除，添加到动态批

​		如果对象在动态批，对象没有移动，就从动态批移除，添加到静止批

4、不管是动态批 还是 静止批，只要所属子对象有移动，就需要更新整个 Mesh，没有变化就不需要更新

5、在对象移动的时候，立即从静止批转换到动态挨批



## HUD 的前后遮挡问题

HUD 的 DrawCall 虽然被合并，但 HUD的前后遮挡关系 可以通过 GPU 硬件的 遮挡算法

HUD 是半透明，所以不能开启 zTest  和 zWrite 开关



解决方案：

1、将 HUD 对象相对摄像机的位置做远近排序，将离摄像机近的排在前面，按照这个先后顺序，离相机近的后写入到 Mesh，然后通过 CommandBuffer 渲染，并适当拆分一些 DrawCall

或者增加一些额外规则，主角的单独使用一个 DrawCall，总是最后渲染

或者同层级的图片与文字，图片总是在文字后面渲染

或者按照摄像机的距离来分层，同一层的合并到一个 DrawCall



2、使用 多纹理技术

修改 HUD 的渲染 Shader，同时传入文字的纹理与三张图片，并在顶点中写入当前顶点所对应的纹理 ID



**3、动态图集的合批技术**

写一个 C++ 的 DLL，绕过 Unity 的文字生成，自己加载字体并且生成字符纹理，再与头顶显示的图片动态生成一个图集

一张 1024x1024 的图片基本可以放下所有 HUD 与 头顶图片信息

即使不行也可以按照前后的层级关系分别生成















# UI自适应





# UI 上显示模型和特效





# 捏脸





# 角色换装





# 聊天
